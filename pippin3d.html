<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>ãƒ”ãƒ”ãƒ³ã®ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ›ãƒƒã‚°ãƒ‡ãƒ¼ - Pippin's Groundhog Day</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;500;600;700&family=Baloo+2:wght@500;600;700;800&display=swap" rel="stylesheet" />
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --cream: #F5F0E6;
      --cream-dark: #EDE7D9;
      --green: #3A7D32;
      --green-light: #5AA152;
      --green-dark: #2D5A27;
      --pink: #E8A0BF;
      --pink-light: #F2C4D6;
      --pink-dark: #D4789E;
      --gold: #F4D06F;
      --lavender: #C5B8E8;
      --white: #FFFFFF;
      --text: #3D3526;
      --text-light: #6B6255;
    }

    body {
      font-family: 'Quicksand', sans-serif;
      background: var(--cream);
      color: var(--text);
      overflow: hidden;
      height: 100vh;
      width: 100vw;
    }

    h1, h2, h3 {
      font-family: 'Baloo 2', cursive;
    }

    /* ======================== 3D CANVAS ======================== */
    #canvas3d {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 0;
    }

    /* ======================== UI OVERLAY ======================== */
    .ui-overlay {
      position: fixed;
      z-index: 10;
      pointer-events: none;
    }

    .ui-overlay > * {
      pointer-events: auto;
    }

    /* Top bar */
    .top-bar {
      top: 0; left: 0; right: 0;
      padding: 1rem 2rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(232, 213, 196, 0.7);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border-bottom: 1px solid rgba(200, 180, 160, 0.4);
    }

    .top-logo {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      font-family: 'Baloo 2', cursive;
      font-size: 1.3rem;
      font-weight: 700;
      color: var(--green-dark);
    }

    .life-info {
      display: flex;
      align-items: center;
      gap: 1.5rem;
    }

    .life-badge {
      background: var(--pink);
      color: white;
      font-family: 'Baloo 2', cursive;
      font-size: 0.85rem;
      font-weight: 700;
      padding: 0.3rem 0.8rem;
      border-radius: 20px;
    }

    .timer {
      font-family: 'Baloo 2', cursive;
      font-size: 1.4rem;
      font-weight: 700;
      color: var(--green-dark);
    }

    .happiness-mini {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 1.2rem;
    }

    .happiness-mini-bar {
      width: 80px;
      height: 10px;
      background: var(--cream-dark);
      border-radius: 10px;
      overflow: hidden;
    }

    .happiness-mini-fill {
      height: 100%;
      border-radius: 10px;
      background: linear-gradient(90deg, #ef5350, #e53935);
      transition: width 0.5s ease, background 0.5s ease;
      transition: width 1s;
    }

    /* Speech bubble */
    .speech-bubble-container {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -280px);
      z-index: 15;
      pointer-events: none;
      display: flex;
      justify-content: center;
    }

    .speech-bubble {
      background: rgba(255, 255, 255, 0.85);
      border: 2px solid rgba(200, 180, 160, 0.5);
      border-radius: 20px;
      padding: 1.2rem 1.8rem;
      max-width: 420px;
      text-align: center;
      font-size: 1rem;
      font-weight: 500;
      color: var(--text);
      font-style: italic;
      box-shadow: 0 8px 40px rgba(61, 53, 38, 0.08);
      position: relative;
      opacity: 0;
      transition: opacity 0.6s ease;
    }

    .speech-bubble.visible {
      opacity: 1;
    }

    .speech-bubble::after {
      content: '';
      position: absolute;
      bottom: -14px;
      left: 50%;
      transform: translateX(-50%);
      width: 0; height: 0;
      border-left: 14px solid transparent;
      border-right: 14px solid transparent;
      border-top: 14px solid var(--white);
    }

    .speech-bubble::before {
      content: '';
      position: absolute;
      bottom: -18px;
      left: 50%;
      transform: translateX(-50%);
      width: 0; height: 0;
      border-left: 16px solid transparent;
      border-right: 16px solid transparent;
      border-top: 16px solid var(--pink-light);
    }

    /* Animation buttons removed - using view toggle only */

    /* Old chat-container CSS removed â€” using global chat panel now */

    /* Loading overlay */
    /* old loading spinner - replaced by new loading screen */
    .loading-sub { display: none; }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* ======================== INTRO OVERLAY ======================== */
    .intro-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #1a1410;
      z-index: 2000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 2rem;
      cursor: pointer;
      transition: opacity 1.5s ease;
    }

    .intro-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .intro-title {
      font-family: 'Baloo 2', cursive;
      font-size: 3rem;
      font-weight: 800;
      color: #E8D5C4;
      text-align: center;
      letter-spacing: 0.05em;
      text-shadow: 0 0 40px rgba(232, 160, 191, 0.3);
    }

    .intro-sub {
      font-family: 'Quicksand', sans-serif;
      font-size: 1.1rem;
      color: rgba(232, 213, 196, 0.5);
      font-weight: 500;
      font-style: italic;
      text-align: center;
      max-width: 400px;
      line-height: 1.6;
    }

    .intro-enter {
      font-family: 'Baloo 2', cursive;
      font-size: 1.2rem;
      font-weight: 700;
      color: #1a1410;
      background: #E8D5C4;
      border: none;
      border-radius: 30px;
      padding: 1rem 3rem;
      cursor: pointer;
      transition: all 0.3s;
      margin-top: 1rem;
      letter-spacing: 0.05em;
    }

    .intro-enter:hover {
      background: var(--pink-light);
      transform: scale(1.05);
      box-shadow: 0 0 30px rgba(232, 160, 191, 0.3);
    }

    .intro-sub-jp {
      font-family: 'Quicksand', sans-serif;
      font-size: 1rem;
      color: rgba(232, 213, 196, 0.7);
      font-weight: 600;
      text-align: center;
      line-height: 1.8;
    }

    .intro-info-btn {
      font-family: 'Quicksand', sans-serif;
      font-size: 0.85rem;
      font-weight: 600;
      color: rgba(232, 213, 196, 0.4);
      background: transparent;
      border: 1px solid rgba(232, 213, 196, 0.2);
      border-radius: 20px;
      padding: 0.5rem 1.5rem;
      cursor: pointer;
      transition: all 0.3s;
      margin-top: 0.5rem;
    }

    .intro-info-btn:hover {
      color: rgba(232, 213, 196, 0.8);
      border-color: rgba(232, 213, 196, 0.5);
    }

    .ca-link {
      display: inline-block;
      margin-top: 1rem;
      font-family: monospace;
      font-size: 0.7rem;
      color: rgba(232, 213, 196, 0.5);
      background: rgba(26, 20, 16, 0.4);
      padding: 0.4rem 0.8rem;
      border-radius: 6px;
      border: 1px solid rgba(232, 213, 196, 0.15);
      cursor: pointer;
      text-decoration: none;
      transition: all 0.2s;
      word-break: break-all;
      max-width: 400px;
    }
    .ca-link:hover {
      color: #e8a0bf;
      border-color: rgba(232, 160, 191, 0.4);
      background: rgba(232, 160, 191, 0.1);
    }
    .ca-label { font-family: 'Quicksand', sans-serif; font-size: 0.65rem; color: rgba(232, 213, 196, 0.35); margin-top: 0.6rem; }
    .ca-header {
      font-family: monospace;
      font-size: 0.6rem;
      color: rgba(232, 213, 196, 0.45);
      background: rgba(26, 20, 16, 0.3);
      padding: 0.2rem 0.6rem;
      border-radius: 4px;
      cursor: pointer;
      text-decoration: none;
      border: 1px solid rgba(232, 213, 196, 0.1);
      transition: all 0.2s;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 180px;
    }
    .ca-header:hover { color: #e8a0bf; border-color: rgba(232, 160, 191, 0.3); }

    /* Gallery */
    .gallery-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(10, 8, 6, 0.92);
      z-index: 900; display: none; overflow-y: auto;
      padding: 2rem;
    }
    .gallery-overlay.show { display: block; }
    .gallery-header {
      display: flex; align-items: center; justify-content: space-between;
      max-width: 900px; margin: 0 auto 1.5rem;
    }
    .gallery-header h2 { font-family: 'Playfair Display', serif; color: #e8a0bf; margin: 0; }
    .gallery-close {
      background: none; border: none; color: #e8d5c4; font-size: 2rem; cursor: pointer;
    }
    .gallery-grid {
      max-width: 900px; margin: 0 auto;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 1rem;
    }
    .gallery-card {
      background: #2a2018; border-radius: 12px; overflow: hidden;
      border: 1px solid rgba(232, 213, 196, 0.1);
      transition: transform 0.2s, border-color 0.2s;
    }
    .gallery-card:hover {
      transform: translateY(-3px);
      border-color: rgba(232, 160, 191, 0.3);
    }
    .gallery-card img {
      width: 100%; aspect-ratio: 1; object-fit: cover;
      background: #fff; display: block;
    }
    .gallery-card-info {
      padding: 0.6rem 0.8rem;
    }
    .gallery-prompt {
      font-size: 0.75rem; color: #c4956a; font-style: italic;
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .gallery-artist {
      font-size: 0.65rem; color: rgba(232, 213, 196, 0.4); margin-top: 0.2rem;
    }
    .gallery-time {
      font-size: 0.6rem; color: rgba(232, 213, 196, 0.25); margin-top: 0.1rem;
    }
    .gallery-share {
      display: flex; align-items: center; gap: 0.3rem;
      margin-top: 0.4rem; padding: 0.3rem 0.5rem;
      background: #1a1410; border: 1px solid rgba(29, 155, 240, 0.3);
      color: #1d9bf0; font-size: 0.65rem; font-weight: bold;
      border-radius: 6px; cursor: pointer; transition: all 0.2s;
      text-decoration: none; width: fit-content;
    }
    .gallery-share:hover { background: rgba(29, 155, 240, 0.15); border-color: #1d9bf0; }
    .gallery-share svg { width: 14px; height: 14px; fill: currentColor; }
    .gallery-actions { display: flex; gap: 0.5rem; align-items: center; margin-top: 0.4rem; }
    .gallery-like {
      display: flex; align-items: center; gap: 0.3rem;
      padding: 0.25rem 0.5rem; border-radius: 6px;
      background: rgba(232, 160, 191, 0.1); border: 1px solid rgba(232, 160, 191, 0.2);
      color: #e8a0bf; font-size: 0.65rem; cursor: pointer; transition: all 0.2s;
    }
    .gallery-like:hover { background: rgba(232, 160, 191, 0.25); border-color: #e8a0bf; }
    .gallery-like.liked { background: rgba(232, 160, 191, 0.3); border-color: #e8a0bf; color: #ff6b9d; }
    .gallery-like-count { font-weight: bold; }
    .gallery-empty {
      text-align: center; color: #888; padding: 3rem; font-size: 1rem;
      grid-column: 1 / -1;
    }

    .intro-enter .pulse {
      display: inline-block;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 1; }
    }

    /* ======================== INFO / DOC POPUP ======================== */
    .doc-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(26, 20, 16, 0.92);
      z-index: 3000;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 2rem;
    }

    .doc-overlay.show {
      display: flex;
    }

    .doc-panel {
      background: #1f1a15;
      border: 1px solid rgba(232, 213, 196, 0.15);
      border-radius: 20px;
      padding: 2.5rem;
      max-width: 520px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
      position: relative;
    }

    .doc-close {
      position: absolute;
      top: 1rem;
      right: 1.2rem;
      font-size: 1.5rem;
      color: rgba(232, 213, 196, 0.4);
      background: none;
      border: none;
      cursor: pointer;
      transition: color 0.2s;
    }

    .doc-close:hover {
      color: rgba(232, 213, 196, 0.8);
    }

    .doc-panel h2 {
      font-family: 'Baloo 2', cursive;
      font-size: 1.6rem;
      color: #E8D5C4;
      margin-bottom: 1.2rem;
    }

    .doc-panel p, .doc-panel li {
      font-family: 'Quicksand', sans-serif;
      font-size: 0.9rem;
      color: rgba(232, 213, 196, 0.65);
      line-height: 1.8;
      margin-bottom: 0.8rem;
    }

    .doc-panel .doc-section {
      margin-bottom: 1.5rem;
    }

    .doc-panel .doc-label {
      font-family: 'Baloo 2', cursive;
      font-size: 0.85rem;
      font-weight: 700;
      color: var(--pink);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 0.3rem;
    }

    .doc-panel ul {
      list-style: none;
      padding: 0;
    }

    .doc-panel li {
      padding-left: 1rem;
      position: relative;
      margin-bottom: 0.4rem;
    }

    .doc-panel li::before {
      content: '>';
      position: absolute;
      left: 0;
      color: var(--pink);
      font-weight: 700;
    }

    /* ======================== TASK PANEL ======================== */
    .task-panel {
      position: fixed;
      top: 60px;
      right: 1rem;
      z-index: 16;
      background: rgba(26, 20, 16, 0.85);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(232, 213, 196, 0.15);
      border-radius: 16px;
      padding: 1rem 1.2rem;
      width: 260px;
      max-height: 400px;
      overflow-y: auto;
      display: none;
    }

    .task-panel.show { display: block; }

    .task-panel h3 {
      font-family: 'Baloo 2', cursive;
      font-size: 1rem;
      color: #E8D5C4;
      margin-bottom: 0.6rem;
    }

    .task-text {
      font-family: 'Quicksand', sans-serif;
      font-size: 0.82rem;
      color: rgba(232, 213, 196, 0.7);
      line-height: 1.6;
      margin-bottom: 0.8rem;
    }

    .task-text .task-en {
      font-size: 0.75rem;
      color: rgba(232, 213, 196, 0.4);
      font-style: italic;
    }

    .task-btn {
      font-family: 'Baloo 2', cursive;
      font-size: 0.8rem;
      font-weight: 700;
      border: none;
      border-radius: 10px;
      padding: 0.4rem 1rem;
      cursor: pointer;
      transition: all 0.2s;
      margin-right: 0.3rem;
      margin-bottom: 0.3rem;
    }

    .task-btn.primary { background: var(--pink); color: #1a1410; }
    .task-btn.secondary { background: rgba(232, 213, 196, 0.2); color: #E8D5C4; }
    .task-btn:hover { transform: translateY(-1px); opacity: 0.9; }

    .task-input {
      width: 100%;
      font-family: 'Quicksand', sans-serif;
      font-size: 0.8rem;
      background: rgba(232, 213, 196, 0.1);
      border: 1px solid rgba(232, 213, 196, 0.2);
      border-radius: 8px;
      padding: 0.5rem;
      color: #E8D5C4;
      margin-bottom: 0.5rem;
      resize: none;
    }

    .task-input:focus { outline: none; border-color: var(--pink); }

    .task-reward {
      font-family: 'Quicksand', sans-serif;
      font-size: 0.7rem;
      color: var(--gold);
      margin-top: 0.3rem;
    }
    .task-retry-btn {
      display: inline-block; margin-top: 0.3rem; padding: 0.25rem 0.7rem;
      background: rgba(232, 90, 90, 0.15); border: 1px solid rgba(232, 90, 90, 0.3);
      color: #e85a5a; border-radius: 6px; cursor: pointer; font-size: 0.65rem;
      font-family: 'Quicksand', sans-serif;
    }
    .task-retry-btn:hover { background: rgba(232, 90, 90, 0.25); }

    /* ======================== WALLET LOGIN ======================== */
    .login-btn {
      position: fixed;
      bottom: 16px;
      left: 8px;
      z-index: 16;
      background: linear-gradient(135deg, rgba(232, 160, 191, 0.25), rgba(196, 149, 106, 0.25));
      backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(232, 160, 191, 0.35);
      border-radius: 14px;
      padding: 0.6rem 1.2rem;
      font-family: 'Baloo 2', cursive;
      font-size: 0.85rem;
      color: #e8a0bf;
      cursor: pointer;
      transition: all 0.25s;
      display: flex; align-items: center; gap: 0.4rem;
    }
    .login-btn:hover {
      background: linear-gradient(135deg, rgba(232, 160, 191, 0.4), rgba(196, 149, 106, 0.4));
      transform: scale(1.03);
    }
    .login-btn.hidden { display: none; }

    .wallet-panel {
      position: fixed;
      bottom: 16px;
      left: 8px;
      z-index: 16;
      background: rgba(26, 20, 16, 0.9);
      backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(232, 213, 196, 0.15);
      border-radius: 16px;
      padding: 0.8rem 1rem;
      width: 280px;
      display: none;
    }
    .wallet-panel.show { display: block; }
    .wallet-panel.joined {
      border-color: rgba(58, 125, 50, 0.4);
      width: auto; min-width: 180px; max-width: 280px;
      padding: 0.5rem 0.8rem;
    }

    .wallet-label {
      font-family: 'Baloo 2', cursive;
      font-size: 0.8rem;
      color: rgba(232, 213, 196, 0.6);
      margin-bottom: 0.5rem;
    }

    .wallet-input {
      width: 100%;
      font-family: 'Quicksand', sans-serif;
      font-size: 0.75rem;
      background: rgba(232, 213, 196, 0.08);
      border: 1px solid rgba(232, 213, 196, 0.2);
      border-radius: 8px;
      padding: 0.5rem 0.7rem;
      color: #E8D5C4;
      margin-bottom: 0.4rem;
      box-sizing: border-box;
    }
    .wallet-input:focus { outline: none; border-color: var(--pink); }
    .wallet-input::placeholder { color: rgba(232, 213, 196, 0.3); }

    .wallet-join-btn {
      width: 100%;
      padding: 0.55rem;
      background: linear-gradient(135deg, rgba(232, 160, 191, 0.3), rgba(196, 149, 106, 0.3));
      border: 1px solid rgba(232, 160, 191, 0.3);
      border-radius: 10px;
      font-family: 'Baloo 2', cursive;
      font-size: 0.85rem;
      color: #e8a0bf;
      cursor: pointer;
      transition: all 0.2s;
    }
    .wallet-join-btn:hover { background: linear-gradient(135deg, rgba(232, 160, 191, 0.45), rgba(196, 149, 106, 0.45)); }

    .wallet-close-btn {
      position: absolute; top: 0.4rem; right: 0.5rem;
      background: none; border: none; color: rgba(232, 213, 196, 0.3);
      font-size: 0.9rem; cursor: pointer; padding: 0.2rem;
    }
    .wallet-close-btn:hover { color: rgba(232, 213, 196, 0.6); }

    .wallet-status {
      font-family: 'Quicksand', sans-serif;
      font-size: 0.7rem;
      color: var(--green-light);
      margin-top: 0.3rem;
    }

    .logged-in-info {
      display: flex; align-items: center; gap: 0.4rem;
      font-family: 'Quicksand', sans-serif;
    }
    .logged-in-dot {
      width: 8px; height: 8px; border-radius: 50%;
      background: #8bc34a; flex-shrink: 0;
    }
    .logged-in-name {
      font-size: 0.8rem; color: #e8a0bf; font-weight: 600;
    }
    .logged-in-wallet {
      font-size: 0.5rem; color: rgba(232, 213, 196, 0.3);
      overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
      max-width: 160px;
    }
    .change-name-btn {
      background: none; border: none;
      color: rgba(232, 213, 196, 0.3);
      font-size: 0.55rem; cursor: pointer; padding: 0;
      text-decoration: underline;
    }
    .change-name-btn:hover { color: rgba(232, 213, 196, 0.6); }

    /* ======================== GLOBAL CHAT PANEL ======================== */
    .gchat-panel {
      position: fixed; left: 8px; top: 52px; bottom: 70px;
      width: 260px; z-index: 25;
      background: rgba(26, 20, 16, 0.75);
      border: 1px solid rgba(232, 213, 196, 0.1);
      border-radius: 12px;
      display: flex; flex-direction: column;
      backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
      overflow: hidden;
    }
    .gchat-header {
      padding: 0.4rem 0.7rem; font-size: 0.7rem; color: #c4956a;
      border-bottom: 1px solid rgba(232, 213, 196, 0.08);
      font-family: 'Baloo 2', cursive; display: flex; align-items: center; gap: 0.4rem;
    }
    .gchat-puzzle {
      padding: 0.5rem 0.7rem;
      background: rgba(232, 160, 191, 0.08);
      border-bottom: 1px solid rgba(232, 213, 196, 0.08);
    }
    .gchat-puzzle-title { font-size: 0.6rem; color: #e8a0bf; font-weight: bold; margin-bottom: 0.2rem; }
    .gchat-puzzle-prompt { font-size: 0.65rem; color: #e8d5c4; margin-bottom: 0.3rem; }
    .gchat-puzzle-bar-outer { height: 6px; background: rgba(232, 213, 196, 0.1); border-radius: 3px; overflow: hidden; }
    .gchat-puzzle-bar-inner { height: 100%; background: linear-gradient(90deg, #e8a0bf, #c4956a); border-radius: 3px; transition: width 0.3s; }
    .gchat-puzzle-count { font-size: 0.55rem; color: rgba(232, 213, 196, 0.4); margin-top: 0.2rem; }
    .gchat-puzzle-btn {
      margin-top: 0.3rem; padding: 0.2rem 0.5rem; font-size: 0.6rem;
      background: rgba(232, 160, 191, 0.2); border: 1px solid rgba(232, 160, 191, 0.3);
      color: #e8a0bf; border-radius: 4px; cursor: pointer;
    }
    .gchat-puzzle-btn:hover { background: rgba(232, 160, 191, 0.35); }
    .gchat-puzzle-contribs { font-size: 0.55rem; color: rgba(232, 213, 196, 0.35); margin-top: 0.2rem; max-height: 60px; overflow-y: auto; }
    .gchat-messages {
      flex: 1; overflow-y: auto; padding: 0.4rem;
      display: flex; flex-direction: column; gap: 0.15rem;
      scrollbar-width: thin; scrollbar-color: rgba(232, 213, 196, 0.1) transparent;
    }
    .gchat-msg {
      font-family: 'Quicksand', sans-serif; font-size: 0.65rem;
      padding: 0.2rem 0.4rem; border-radius: 4px; word-break: break-word;
    }
    .gchat-msg.type-chat { color: #e8d5c4; }
    .gchat-msg.type-chat .gchat-name { color: #e8a0bf; font-weight: 600; }
    .gchat-msg.type-activity { color: rgba(232, 213, 196, 0.35); font-size: 0.58rem; font-style: italic; }
    .gchat-msg.type-pippin {
      background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.15);
      color: #c5b8e8;
    }
    .gchat-msg.type-pippin .gchat-name { color: #8b5cf6; font-weight: bold; }
    .gchat-time { font-size: 0.45rem; color: rgba(232, 213, 196, 0.2); margin-left: 0.3rem; }
    .gchat-input-area {
      padding: 0.4rem; border-top: 1px solid rgba(232, 213, 196, 0.08);
      display: flex; gap: 0.3rem;
    }
    .gchat-input {
      flex: 1; background: rgba(232, 213, 196, 0.06); border: 1px solid rgba(232, 213, 196, 0.12);
      border-radius: 6px; padding: 0.35rem 0.5rem; font-size: 0.7rem; color: #e8d5c4;
      font-family: 'Quicksand', sans-serif; outline: none;
    }
    .gchat-input::placeholder { color: rgba(232, 213, 196, 0.25); }
    .gchat-input:focus { border-color: rgba(232, 160, 191, 0.4); }
    .gchat-send-btn {
      padding: 0.3rem 0.6rem; background: rgba(232, 160, 191, 0.2);
      border: 1px solid rgba(232, 160, 191, 0.3); border-radius: 6px;
      color: #e8a0bf; font-size: 0.65rem; cursor: pointer;
    }
    .gchat-send-btn:hover { background: rgba(232, 160, 191, 0.35); }
    .gchat-toggle {
      display: none; position: fixed; left: 0.5rem; bottom: 60px;
      z-index: 25; padding: 0.4rem 0.6rem; border-radius: 8px;
      background: rgba(26, 20, 16, 0.85); border: 1px solid rgba(232, 213, 196, 0.15);
      color: #e8a0bf; font-size: 0.75rem; cursor: pointer;
    }
    .gchat-toggle:hover { background: rgba(26, 20, 16, 0.95); }

    /* ======================== DRAW CANVAS OVERLAY ======================== */
    .canvas-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(26, 20, 16, 0.9);
      z-index: 2500;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 0.8rem;
      overflow-y: auto;
      padding: 1rem 0;
    }

    .canvas-overlay.show { display: flex; }

    .canvas-prompt {
      font-family: 'Baloo 2', cursive;
      font-size: 1.1rem;
      color: #E8D5C4;
      text-align: center;
      max-width: 700px;
    }

    .canvas-prompt .canvas-prompt-en {
      font-family: 'Quicksand', sans-serif;
      font-size: 0.8rem;
      color: rgba(232, 213, 196, 0.4);
      font-style: italic;
      display: block;
      margin-top: 0.3rem;
    }

    .draw-canvas {
      background: #fff;
      border-radius: 12px;
      cursor: crosshair;
      touch-action: none;
      width: 700px;
      height: 700px;
    }

    .canvas-toolbar {
      display: flex; flex-direction: column; gap: 0.4rem; align-items: center; width: 100%; max-width: 700px;
    }
    .canvas-tools {
      display: flex; gap: 0.3rem; align-items: center; flex-wrap: wrap; justify-content: center;
    }
    .color-btn {
      width: 24px; height: 24px; border-radius: 50%;
      border: 2px solid rgba(232, 213, 196, 0.2); cursor: pointer; transition: transform 0.15s;
    }
    .color-btn:hover, .color-btn.active { transform: scale(1.25); border-color: #E8D5C4; }
    .eraser-btn {
      background: #fff !important;
      font-size: 12px; display: flex; align-items: center; justify-content: center; color: #333;
    }
    .eraser-btn.active { border-color: #ef5350 !important; box-shadow: 0 0 6px rgba(239, 83, 80, 0.4); }

    .brush-row {
      display: flex; gap: 0.4rem; align-items: center; justify-content: center;
    }
    .brush-row-label {
      font-size: 0.6rem; color: rgba(232, 213, 196, 0.4); min-width: 35px; text-align: right;
    }
    .size-btn {
      width: 30px; height: 30px; border-radius: 6px;
      background: rgba(232, 213, 196, 0.08); border: 1px solid rgba(232, 213, 196, 0.15);
      cursor: pointer; display: flex; align-items: center; justify-content: center;
      transition: all 0.15s; color: #e8d5c4;
    }
    .size-btn:hover { background: rgba(232, 213, 196, 0.15); }
    .size-btn.active { border-color: #e8a0bf; background: rgba(232, 160, 191, 0.2); }
    .size-dot { background: #e8d5c4; border-radius: 50%; }

    .brush-type-btn {
      padding: 0.2rem 0.5rem; border-radius: 6px;
      background: rgba(232, 213, 196, 0.08); border: 1px solid rgba(232, 213, 196, 0.15);
      cursor: pointer; font-size: 0.65rem; color: #e8d5c4; transition: all 0.15s;
    }
    .brush-type-btn:hover { background: rgba(232, 213, 196, 0.15); }
    .brush-type-btn.active { border-color: #e8a0bf; background: rgba(232, 160, 191, 0.2); color: #e8a0bf; }

    .canvas-actions {
      display: flex;
      gap: 0.5rem;
    }

    /* View toggle only - no more animation buttons bar */
    /* view-toggle-btn removed */

    /* ======================== HELP BUTTON & POPUP ======================== */
    .help-btn {
      position: fixed;
      bottom: 130px;
      right: 2rem;
      z-index: 15;
      width: 40px;
      height: 40px;
      background: rgba(232, 213, 196, 0.7);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(200, 180, 160, 0.4);
      border-radius: 50%;
      font-family: 'Baloo 2', cursive;
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s;
    }
    .help-btn:hover {
      background: rgba(232, 160, 191, 0.5);
      transform: translateY(-2px);
    }

    .help-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(10, 8, 5, 0.7);
      z-index: 100;
      display: none;
      justify-content: center;
      align-items: center;
    }
    .help-overlay.show { display: flex; }

    .help-popup {
      background: rgba(26, 20, 16, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(232, 213, 196, 0.15);
      border-radius: 20px;
      padding: 2rem 2.5rem;
      max-width: 520px;
      width: 90%;
      position: relative;
      animation: fadeUp 0.3s ease;
    }

    .help-popup h3 {
      font-family: 'Baloo 2', cursive;
      font-size: 1.4rem;
      color: var(--pink);
      margin-bottom: 1rem;
    }

    .help-close {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: none;
      border: none;
      color: rgba(232, 213, 196, 0.4);
      font-size: 1.5rem;
      cursor: pointer;
      transition: color 0.2s;
    }
    .help-close:hover { color: #E8D5C4; }

    .help-steps p {
      font-family: 'Quicksand', sans-serif;
      font-size: 0.85rem;
      color: rgba(232, 213, 196, 0.75);
      line-height: 1.8;
      margin: 0;
    }
    .help-steps p b {
      color: #E8D5C4;
    }

    .help-keys {
      margin-top: 1.2rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      font-family: 'Quicksand', sans-serif;
      font-size: 0.75rem;
      color: rgba(232, 213, 196, 0.5);
    }

    .key-tag {
      display: inline-block;
      background: rgba(232, 213, 196, 0.12);
      border: 1px solid rgba(232, 213, 196, 0.2);
      border-radius: 6px;
      padding: 0.15rem 0.5rem;
      font-family: 'Courier New', monospace;
      font-size: 0.72rem;
      color: var(--gold);
    }

    /* ======================== RANKING ======================== */
    .ranking-btn {
      background: rgba(232, 213, 196, 0.15);
      border: 1px solid rgba(232, 213, 196, 0.25);
      border-radius: 10px;
      padding: 0.3rem 0.8rem;
      font-family: 'Baloo 2', cursive;
      font-size: 0.75rem;
      font-weight: 700;
      color: #E8D5C4;
      cursor: pointer;
      transition: all 0.2s;
      margin-left: 0.5rem;
    }
    .ranking-btn:hover {
      background: rgba(232, 160, 191, 0.3);
      transform: translateY(-1px);
    }

    .ranking-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(10, 8, 5, 0.75);
      z-index: 100;
      display: none;
      justify-content: center;
      align-items: center;
    }
    .ranking-overlay.show { display: flex; }

    .ranking-popup {
      background: rgba(26, 20, 16, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(232, 213, 196, 0.15);
      border-radius: 20px;
      padding: 2rem 2.5rem;
      max-width: 480px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      position: relative;
      animation: fadeUp 0.3s ease;
    }

    .ranking-popup h3 {
      font-family: 'Baloo 2', cursive;
      font-size: 1.3rem;
      color: var(--pink);
      margin-bottom: 0.5rem;
    }

    .ranking-close {
      position: absolute;
      top: 1rem; right: 1rem;
      background: none; border: none;
      color: rgba(232, 213, 196, 0.4);
      font-size: 1.5rem;
      cursor: pointer;
      transition: color 0.2s;
    }
    .ranking-close:hover { color: #E8D5C4; }

    .ranking-meta {
      font-family: 'Quicksand', sans-serif;
      font-size: 0.75rem;
      color: rgba(232, 213, 196, 0.45);
      margin-bottom: 1rem;
    }

    .ranking-list {
      display: flex;
      flex-direction: column;
      gap: 0;
    }

    .ranking-loading {
      text-align: center;
      color: rgba(232, 213, 196, 0.4);
      font-family: 'Quicksand', sans-serif;
      font-size: 0.8rem;
      padding: 2rem;
    }

    .rank-row {
      display: flex;
      align-items: center;
      gap: 0.7rem;
      padding: 0.55rem 0.6rem;
      border-bottom: 1px solid rgba(232, 213, 196, 0.06);
      font-family: 'Quicksand', sans-serif;
      font-size: 0.8rem;
      color: rgba(232, 213, 196, 0.7);
      transition: background 0.15s;
    }
    .rank-row:hover { background: rgba(232, 213, 196, 0.04); }

    .rank-row.me { background: rgba(232, 160, 191, 0.1); border-radius: 8px; }

    .rank-pos {
      width: 28px;
      text-align: center;
      font-family: 'Baloo 2', cursive;
      font-weight: 700;
      font-size: 0.9rem;
      color: rgba(232, 213, 196, 0.5);
      flex-shrink: 0;
    }
    .rank-row:nth-child(1) .rank-pos { color: #FFD700; font-size: 1.1rem; }
    .rank-row:nth-child(2) .rank-pos { color: #C0C0C0; font-size: 1rem; }
    .rank-row:nth-child(3) .rank-pos { color: #CD7F32; font-size: 1rem; }

    .rank-wallet {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: #E8D5C4;
      font-weight: 600;
    }

    .rank-stats {
      display: flex;
      gap: 0.8rem;
      font-size: 0.72rem;
      color: rgba(232, 213, 196, 0.45);
      flex-shrink: 0;
    }

    .rank-stat {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: 40px;
    }

    .rank-stat-val {
      font-family: 'Baloo 2', cursive;
      font-weight: 700;
      font-size: 0.85rem;
      color: var(--gold);
    }

    .rank-stat-label {
      font-size: 0.6rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* ======================== INTRO HOW-TO ======================== */
    .intro-howto {
      margin-top: 1.5rem;
      background: rgba(26, 20, 16, 0.5);
      border: 1px solid rgba(232, 213, 196, 0.1);
      border-radius: 16px;
      padding: 1.2rem 1.5rem;
      text-align: left;
      max-width: 460px;
      width: 90%;
    }

    .howto-title {
      font-family: 'Baloo 2', cursive;
      font-size: 1rem;
      color: var(--pink);
      margin-bottom: 0.8rem;
      text-align: center;
    }

    .howto-steps {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .howto-step {
      display: flex;
      align-items: flex-start;
      gap: 0.7rem;
      font-family: 'Quicksand', sans-serif;
      font-size: 0.8rem;
      color: rgba(232, 213, 196, 0.7);
      line-height: 1.5;
    }

    .howto-step b {
      color: #E8D5C4;
    }

    .howto-num {
      flex-shrink: 0;
      width: 22px;
      height: 22px;
      background: var(--pink);
      color: #1a1410;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Baloo 2', cursive;
      font-size: 0.75rem;
      font-weight: 700;
    }

    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(20px); }
      to   { opacity: 1; transform: translateY(0); }
    }

    .move-hint {
      position: fixed;
      bottom: 95px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 15;
      font-family: 'Quicksand', sans-serif;
      font-size: 0.75rem;
      font-weight: 600;
      color: rgba(61, 53, 38, 0.5);
      background: rgba(232, 213, 196, 0.5);
      backdrop-filter: blur(8px);
      padding: 0.4rem 1.2rem;
      border-radius: 20px;
      pointer-events: none;
      transition: opacity 3s ease;
    }

    .move-hint.faded {
      opacity: 0;
    }

    /* ======================== MOBILE JOYSTICK ======================== */
    .touch-joystick {
      position: fixed;
      bottom: 100px;
      left: 30px;
      z-index: 18;
      width: 120px;
      height: 120px;
      display: none;
      touch-action: none;
    }

    .joystick-base {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: rgba(232, 213, 196, 0.25);
      border: 2px solid rgba(232, 213, 196, 0.35);
      position: relative;
    }

    .joystick-knob {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(232, 160, 191, 0.5);
      border: 2px solid rgba(232, 160, 191, 0.7);
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: none;
    }

    .touch-fly-btns {
      position: fixed;
      bottom: 100px;
      right: 20px;
      z-index: 18;
      display: none;
      flex-direction: column;
      gap: 10px;
    }

    .fly-btn {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: rgba(232, 213, 196, 0.3);
      border: 2px solid rgba(232, 213, 196, 0.4);
      font-size: 1.4rem;
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: none;
      cursor: pointer;
    }

    .fly-btn:active { background: rgba(232, 160, 191, 0.4); }

    /* ======================== MOBILE RESPONSIVE ======================== */
    @media (max-width: 768px) {
      .top-bar { padding: 0.5rem 0.8rem; }
      .top-logo { font-size: 0.85rem; gap: 0.3rem; }
      .life-info { gap: 0.5rem; }
      .life-badge { font-size: 0.65rem; padding: 0.2rem 0.5rem; }
      .timer { font-size: 0.9rem; }
      .happiness-mini { font-size: 0.9rem; gap: 0.3rem; }
      .happiness-mini-bar { width: 40px; }
      .ranking-btn { font-size: 0.6rem; padding: 0.2rem 0.5rem; margin-left: 0.3rem; }

      .speech-bubble {
        max-width: 70vw;
        font-size: 0.8rem;
        padding: 0.6rem 1rem;
      }

      .intro-title { font-size: 1.8rem; }
      .intro-sub-jp { font-size: 0.8rem; }
      .intro-sub { font-size: 0.85rem; }
      .intro-enter { font-size: 1rem; padding: 0.8rem 2rem; }
      .intro-info-btn { font-size: 0.7rem; padding: 0.35rem 1rem; }
      .intro-howto { padding: 0.8rem 1rem; margin-top: 1rem; }
      .howto-title { font-size: 0.85rem; }
      .howto-step { font-size: 0.7rem; gap: 0.5rem; }
      .howto-num { width: 18px; height: 18px; font-size: 0.65rem; }

      .task-panel {
        top: 50px;
        right: 0.5rem;
        width: 200px;
        padding: 0.7rem 0.8rem;
        max-height: 250px;
      }
      .task-panel h3 { font-size: 0.8rem; }
      .task-text { font-size: 0.7rem; }
      .task-btn { font-size: 0.7rem; padding: 0.3rem 0.7rem; }

      .login-btn { bottom: 12px; left: 4px; font-size: 0.75rem; padding: 0.45rem 0.9rem; z-index: 16; }
      .wallet-panel {
        bottom: 12px;
        left: 4px;
        width: 220px;
        padding: 0.6rem 0.7rem;
      }
      .wallet-label { font-size: 0.65rem; }
      .wallet-input { font-size: 0.65rem; padding: 0.3rem 0.5rem; }
      .wallet-join-btn { font-size: 0.75rem; padding: 0.4rem; }

      .help-btn {
        bottom: 75px;
        right: 0.8rem;
        width: 34px;
        height: 34px;
        font-size: 0.9rem;
      }

      .move-hint { font-size: 0.6rem; bottom: 72px; }

      .touch-joystick { display: block; }
      .touch-fly-btns { display: flex; }
      .move-hint { display: none; }

      .help-popup, .ranking-popup, .doc-panel {
        padding: 1.5rem;
        max-width: 92vw;
      }
      .help-popup h3, .ranking-popup h3 { font-size: 1.1rem; }
      .help-steps p { font-size: 0.75rem; }

      .canvas-overlay .draw-canvas {
        width: 90vw;
        height: 90vw;
        max-width: 700px;
        max-height: 700px;
      }
      .canvas-toolbar { max-width: 95vw; }
      .color-btn { width: 20px; height: 20px; }
      .size-btn { width: 26px; height: 26px; }
      .brush-type-btn { font-size: 0.55rem; padding: 0.15rem 0.35rem; }
      .brush-row-label { font-size: 0.5rem; min-width: 25px; }
      .brush-row { gap: 0.25rem; flex-wrap: wrap; }

      /* Global chat: collapsible on mobile */
      .gchat-panel {
        display: none;
        width: 85vw; max-width: 260px;
        z-index: 30;
        left: 4px; top: 48px; bottom: 60px;
      }
      .gchat-toggle { display: block; }
    }

    @media (max-width: 400px) {
      .top-logo { font-size: 0.7rem; }
      .timer { font-size: 0.75rem; }
      .ranking-btn { display: none; }
      .lang-toggle-btn { display: inline-block !important; font-size: 0.6rem !important; padding: 0.2rem 0.4rem !important; }
      #galleryBtn { display: inline-block !important; font-size: 0.55rem !important; padding: 0.2rem 0.4rem !important; }
      .ca-header { display: none; }
      .gallery-grid { grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 0.6rem; }
      .gallery-overlay { padding: 1rem; }
      .ca-link { font-size: 0.55rem; padding: 0.3rem 0.5rem; max-width: 280px; }
      .ca-label { font-size: 0.55rem; }
      .intro-title { font-size: 1.4rem; }
      .task-panel { width: 170px; }
      .wallet-panel { width: 190px; }
      .login-btn { font-size: 0.7rem; padding: 0.35rem 0.7rem; }
    }
    /* Loading Screen */
    .loading-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #1a1410;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      z-index: 10000;
      transition: opacity 0.5s;
    }
    .loading-overlay.hidden { opacity: 0; pointer-events: none; }
    .loading-title { font-family: 'Playfair Display', serif; color: #e8a0bf; font-size: 1.8rem; margin-bottom: 1rem; }
    .loading-unicorn { font-size: 3rem; animation: loadBounce 1s infinite; }
    @keyframes loadBounce { 0%,100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
    .loading-bar-outer { width: 300px; height: 8px; background: #2a2018; border-radius: 4px; margin-top: 1.5rem; overflow: hidden; }
    .loading-bar-inner { height: 100%; width: 0%; background: linear-gradient(90deg, #e8a0bf, #c4956a); border-radius: 4px; transition: width 0.3s; }
    .loading-text { color: #888; font-size: 0.8rem; margin-top: 0.5rem; }
  </style>
</head>
<body>

  <!-- LOADING SCREEN -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-unicorn">ğŸ¦„</div>
    <div class="loading-title">ãƒ”ãƒ”ãƒ³ã®ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ›ãƒƒã‚°ãƒ‡ãƒ¼</div>
    <div class="loading-bar-outer"><div class="loading-bar-inner" id="loadingBar"></div></div>
    <div class="loading-text" id="loadingText">Loading world desu...</div>
  </div>

  <!-- INTRO OVERLAY - click to enter -->
  <div class="intro-overlay" id="introOverlay">
    <div class="intro-title">ãƒ”ãƒ”ãƒ³ã®ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ›ãƒƒã‚°ãƒ‡ãƒ¼</div>
    <div class="intro-sub-jp">ä¸æ€è­°ãªä¸–ç•Œã«è¿·ã„è¾¼ã‚“ã ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ³ã€‚<br>æ­©ã„ã¦ã€é£›ã‚“ã§ã€è©±ã—ã‹ã‘ã¦ã€‚</div>
    <div class="intro-sub">Pippin's Groundhog Day</div>

    <div class="intro-howto">
      <div class="howto-title">éŠã³æ–¹ / How to Play desu!</div>
      <div class="howto-steps">
        <div class="howto-step"><span class="howto-num">1</span><span>Enter sekai and explore ne â€” move Pippin with <b>WASD</b>, fly with <b>Space/Shift</b> desu!</span></div>
        <div class="howto-step"><span class="howto-num">2</span><span>Talk to Pippin ne â€” type in chat bar at bottom desu</span></div>
        <div class="howto-step"><span class="howto-num">3</span><span>Register your <b>SOL wallet</b> (bottom-left panel) to sanka suru ne!</span></div>
        <div class="howto-step"><span class="howto-num">4</span><span>Complete <b>tasks</b> Pippin asks for (top-right panel) â€” write, draw, odoru!</span></div>
        <div class="howto-step"><span class="howto-num">5</span><span>Each task raises Pippin's <b>happiness</b> and earns you <b>raffle entry</b> desu yo!</span></div>
        <div class="howto-step"><span class="howto-num">6</span><span>When timer hits zero, <b>winner is drawn</b> from all entries ne! Gambatte!</span></div>
      </div>
    </div>

    <button class="intro-enter" id="introEnter"><span class="pulse">&#9654;</span>&nbsp; å…¥ã‚‹</button>
    <button class="intro-info-btn" id="introInfoBtn">?&nbsp; ã“ã‚Œã¯ä½•ï¼Ÿ</button>
    <div class="ca-label">CA (Solana)</div>
    <a class="ca-link" id="caLinkIntro" href="https://pump.fun/coin/4srVZphD4XnXmV2iGs2diQs644Po7njkBBU4wdZspump" target="_blank" rel="noopener">4srVZphD4XnXmV2iGs2diQs644Po7njkBBU4wdZspump</a>
  </div>

  <!-- Doc / Info Popup -->
  <div class="doc-overlay" id="docOverlay">
    <div class="doc-panel">
      <button class="doc-close" id="docClose">&times;</button>
      <h2>ãƒ”ãƒ”ãƒ³ã®ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ›ãƒƒã‚°ãƒ‡ãƒ¼ã«ã¤ã„ã¦</h2>

      <div class="doc-section">
        <div class="doc-label">ã“ã‚Œã¯ä½•ï¼Ÿ</div>
        <p>ã€Œãƒ”ãƒ”ãƒ³ã®ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ›ãƒƒã‚°ãƒ‡ãƒ¼ã€ã¯ã€ä¸æ€è­°ãªæ¬¡å…ƒã«è¿·ã„è¾¼ã‚“ã ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ³ãƒ»ãƒ”ãƒ”ãƒ³ã®ç‰©èªã§ã™ã€‚ã‚µã‚¤ã‚±ãƒ‡ãƒªãƒƒã‚¯ãªå·ã€è¸Šã‚‹ã‚­ãƒã‚³ãŸã¡ã€ãã—ã¦çµ‚ã‚ã‚‰ãªã„æ™‚é–“ã®ãƒ«ãƒ¼ãƒ—ã®ä¸­ã§ã€ãƒ”ãƒ”ãƒ³ã¯æ­©ãã€é£›ã³ã€ãã—ã¦èªã‚Šã‹ã‘ã¦ãã‚Œã‚‹ã‚ãªãŸã‚’å¾…ã£ã¦ã„ã¾ã™ã€‚</p>
      </div>

      <div class="doc-section">
        <div class="doc-label">æ“ä½œæ–¹æ³•</div>
        <ul>
          <li>WASD / çŸ¢å°ã‚­ãƒ¼ï¼šæ­©ããƒ»ç§»å‹•ã™ã‚‹</li>
          <li>ã‚¹ãƒšãƒ¼ã‚¹ï¼šç©ºã‚’é£›ã¶ï¼ˆä¸Šæ˜‡ï¼‰</li>
          <li>ã‚·ãƒ•ãƒˆï¼šé™ä¸‹ã™ã‚‹</li>
          <li>ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚°ï¼šã‚«ãƒ¡ãƒ©ã‚’å›è»¢</li>
          <li>ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼šã‚ºãƒ¼ãƒ ã‚¤ãƒ³ãƒ»ã‚¢ã‚¦ãƒˆ</li>
          <li>V ã‚­ãƒ¼ï¼šä¸€äººç§°è¦–ç‚¹ã®åˆ‡ã‚Šæ›¿ãˆ</li>
          <li>ãƒãƒ£ãƒƒãƒˆï¼šãƒ”ãƒ”ãƒ³ã«è©±ã—ã‹ã‘ã‚ˆã†ï¼æ—¥æœ¬èªã§è¿”äº‹ã™ã‚‹ã‚ˆ</li>
        </ul>
      </div>

      <div class="doc-section">
        <div class="doc-label">ãƒ”ãƒ”ãƒ³ã¨ã¯ï¼Ÿ</div>
        <p>ãƒ”ãƒ”ãƒ³ã¯ã‚«ãƒ¯ã‚¤ã‚¤ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ³ã§ã™ã€‚ã‚¿ã‚¤ãƒ ãƒ«ãƒ¼ãƒ—ã«é–‰ã˜è¾¼ã‚ã‚‰ã‚Œã€ä½•åº¦ã‚‚ç”Ÿã¾ã‚Œå¤‰ã‚ã‚Šã¾ã™ã€‚ã§ã‚‚ãƒ”ãƒ”ãƒ³ã¯æ°—ã«ã—ã¾ã›ã‚“ã€‚ãƒã‚¤ãƒ–ã‚¹ãŒå¤§äº‹ã ã‹ã‚‰ã€‚ãƒ”ãƒ”ãƒ³ã«è©±ã—ã‹ã‘ã‚‹ã¨ã€æ—¥æœ¬èªã§ç­”ãˆã¦ãã‚Œã¾ã™ã€‚å­—å¹•ã¯è‹±èªã§è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</p>
      </div>

      <div class="doc-section">
        <div class="doc-label">ä¸–ç•Œè¦³</div>
        <p>ã“ã®ä¸–ç•Œã¯ãƒãƒƒã‚¯ãƒ«ãƒ¼ãƒ ã®ã‚ˆã†ãªä¸æ€è­°ãªç©ºé–“ã§ã™ã€‚è™¹è‰²ã®å·ãŒæµã‚Œã€ã‚­ãƒã‚³ã®äººã€…ãŒæ°¸é ã«è¸Šã‚Šç¶šã‘ã¦ã„ã¾ã™ã€‚ç¾ã—ãã¦ã€å°‘ã—ä¸æ°—å‘³ã§ã€ã§ã‚‚ã©ã“ã‹å±…å¿ƒåœ°ãŒã„ã„ã€‚ãƒ”ãƒ”ãƒ³ã¯ã“ã“ãŒå¥½ãã§ã™ã€‚ãŸã¶ã‚“ã€‚</p>
      </div>

      <div class="doc-section">
        <div class="doc-label">è‡ªå·±é€²åŒ–ã™ã‚‹ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼</div>
        <p>ãƒ”ãƒ”ãƒ³ã¯é™çš„ãªã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚Pippinãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ï¼ˆpippin.loveï¼‰ã‚’åŸºç›¤ã«æ§‹ç¯‰ã•ã‚ŒãŸè‡ªå¾‹å‹AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ã™ã€‚ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã¨ã®å¯¾è©±ã‚’é€šã˜ã¦å­¦ã³ã€é€²åŒ–ã—ã€ã‚¿ã‚¹ã‚¯ã‚’å‡ºã—ã€æ„Ÿæƒ…ã‚’å¤‰åŒ–ã•ã›ã¾ã™ã€‚ã‚ãªãŸã®è¡Œå‹•ãŒãƒ”ãƒ”ãƒ³ã®æ€§æ ¼ã¨ä¸–ç•Œã‚’å½¢ä½œã‚Šã¾ã™ã€‚</p>
        <p>ãƒ©ã‚¤ãƒ•ãŒçµ‚ã‚ã‚‹ãŸã³ã«ã€ãƒ”ãƒ”ãƒ³ã¯ãƒªã‚¹ãƒãƒ¼ãƒ³ã—ã€å‰ã®ãƒ©ã‚¤ãƒ•ã®è¨˜æ†¶ã‚’æ–­ç‰‡çš„ã«æŒã¡ãªãŒã‚‰æ–°ã—ã„å­˜åœ¨ã¨ã—ã¦ç”Ÿã¾ã‚Œå¤‰ã‚ã‚Šã¾ã™ã€‚ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ãŒä¸ãˆãŸã‚¿ã‚¹ã‚¯ã€æã„ãŸçµµã€èªã£ãŸç‰©èª â”€â”€ ã™ã¹ã¦ãŒãƒ”ãƒ”ãƒ³ã®é€²åŒ–ã«å½±éŸ¿ã—ã¾ã™ã€‚</p>
      </div>

      <div class="doc-section">
        <div class="doc-label">Pippinãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯</div>
        <p>æœ¬ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯Pippinï¼ˆpippin.loveï¼‰ã®è‡ªå¾‹å‹AIã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚’æ´»ç”¨ã—ã¦ã„ã¾ã™ã€‚ãƒ”ãƒ”ãƒ³ã¯ãŸã ã®ãƒãƒ£ãƒƒãƒˆãƒœãƒƒãƒˆã§ã¯ãªãã€è‡ªåˆ†ã§è€ƒãˆã€ã‚¿ã‚¹ã‚¯ã‚’ç”Ÿæˆã—ã€ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã®è¡Œå‹•ã«åŸºã¥ã„ã¦æ„Ÿæƒ…çŠ¶æ…‹ã‚’å¤‰åŒ–ã•ã›ã‚‹ã€è‡ªå·±é€²åŒ–å‹ã®AIã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã§ã™ã€‚</p>
      </div>
    </div>
  </div>

  <!-- Loading (old, replaced by new loading screen above) -->
  <div id="oldLoadingOverlay" style="display:none">
    <div class="loading-sub" id="loadingStatus">èª­ã¿è¾¼ã¿ä¸­...</div>
  </div>

  <!-- 3D Canvas -->
  <canvas id="canvas3d"></canvas>

  <!-- Background Music -->
  <audio id="bgMusic" loop preload="auto">
    <source src="music/bgm.mp3" type="audio/mpeg">
  </audio>

  <!-- Speech Bubble -->
  <div class="speech-bubble-container">
    <div class="speech-bubble" id="speechBubble">
      ...
    </div>
  </div>

  <!-- Top Bar -->
  <div class="ui-overlay top-bar">
    <div class="top-logo">&#129412; ãƒ”ãƒ”ãƒ³ã®ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ›ãƒƒã‚°ãƒ‡ãƒ¼</div>
    <div class="life-info">
      <div class="life-badge">Life #1</div>
      <div class="timer" id="miniTimer">00:29:59</div>
      <div class="happiness-mini">
        <span id="miniHappyFace">&#128546;</span>
        <div class="happiness-mini-bar">
          <div class="happiness-mini-fill" id="miniHappyFill" style="width: 0%"></div>
        </div>
      </div>
      <button class="ranking-btn" id="rankingBtn">&#127942; ãƒ©ãƒ³ã‚­ãƒ³ã‚°</button>
      <button class="ranking-btn" id="galleryBtn">&#127912; ã‚®ãƒ£ãƒ©ãƒªãƒ¼</button>
      <button class="ranking-btn lang-toggle-btn" id="langToggle" title="Speaking Japanese">ğŸ‡¯ğŸ‡µ JP</button>
      <a class="ca-header" id="caLinkHeader" href="https://pump.fun/coin/4srVZphD4XnXmV2iGs2diQs644Po7njkBBU4wdZspump" target="_blank" rel="noopener" title="CA: 4srVZphD4XnXmV2iGs2diQs644Po7njkBBU4wdZspump">CA: 4srVZ...spump</a>
    </div>
  </div>

  <!-- Ranking Popup -->
  <div class="ranking-overlay" id="rankingOverlay">
    <div class="ranking-popup">
      <button class="ranking-close" id="rankingClose">&times;</button>
      <h3>&#127942; ãƒ©ãƒ³ã‚­ãƒ³ã‚° / Leaderboard</h3>
      <div class="ranking-meta" id="rankingMeta"></div>
      <div class="ranking-list" id="rankingList">
        <div class="ranking-loading">èª­ã¿è¾¼ã¿ä¸­...</div>
      </div>
    </div>
  </div>

  <button class="help-btn" id="helpBtn">?</button>

  <!-- Drawing Gallery -->
  <div class="gallery-overlay" id="galleryOverlay">
    <div class="gallery-header">
      <h2>ğŸ¨ ã‚®ãƒ£ãƒ©ãƒªãƒ¼ / Gallery</h2>
      <button class="gallery-close" id="galleryClose">&times;</button>
    </div>
    <div class="gallery-grid" id="galleryGrid">
      <div class="gallery-empty">Loading drawings desu...</div>
    </div>
  </div>

  <!-- In-game Help Popup -->
  <div class="help-overlay" id="helpOverlay">
    <div class="help-popup">
      <button class="help-close" id="helpClose">&times;</button>
      <h3>éŠã³æ–¹ / How to Play desu!</h3>
      <div class="help-steps">
        <p><b>1.</b> Move Pippin: <b>WASD</b> / arrows ne &middot; Fly: <b>Space</b> (up) / <b>Shift</b> (down) desu</p>
        <p><b>2.</b> Talk to Pippin: type in <b>chat bar</b> at bottom and press Enter ne!</p>
        <p><b>3.</b> Register your <b>SOL wallet</b> in bottom-left panel to sanka suru!</p>
        <p><b>4.</b> After joining, <b>task panel</b> appears top-right â€” Pippin will ask you things desu!</p>
        <p><b>5.</b> Tasks can be: <b>write</b> something, <b>draw</b> on canvas, <b>odoru</b>, or <b>explore</b>!</p>
        <p><b>6.</b> Drawing tasks open <b>full canvas</b> â€” pick colors, draw, and submit ne!</p>
        <p><b>7.</b> Each task raises Pippin's <b>happiness</b> and earns you <b>raffle entry</b> desu yo!</p>
        <p><b>8.</b> When <b>timer</b> hits zero, <b>winner is drawn</b> from all entries! Gambatte!</p>
      </div>
      <div class="help-keys">
        <span class="key-tag">W/A/S/D</span> ugoku
        <span class="key-tag">Space</span> fly up desu
        <span class="key-tag">Shift</span> fly down ne
        <span class="key-tag">Enter</span> chat!
      </div>
    </div>
  </div>

  <!-- Movement hint -->
  <div class="move-hint" id="moveHint">WASD / arrows to move &middot; space to fly up &middot; shift to fly down</div>

  <!-- Mobile Touch Controls -->
  <div class="touch-joystick" id="touchJoystick">
    <div class="joystick-base">
      <div class="joystick-knob" id="joystickKnob"></div>
    </div>
  </div>
  <div class="touch-fly-btns" id="touchFlyBtns">
    <button class="fly-btn" id="flyUpBtn">&#9650;</button>
    <button class="fly-btn" id="flyDownBtn">&#9660;</button>
  </div>

  <!-- Task Panel -->
  <div class="task-panel" id="taskPanel">
    <h3>&#127775; ãƒ”ãƒ”ãƒ³ã®ãŠé¡˜ã„</h3>
    <div class="task-text" id="taskText">...</div>
    <div id="taskInputArea"></div>
    <div>
      <button class="task-btn primary" id="taskSubmit" style="display:none;">é€ã‚‹</button>
      <button class="task-btn secondary" id="taskSkip">æ¬¡ã®ã‚¿ã‚¹ã‚¯</button>
    </div>
    <div class="task-reward" id="taskReward"></div>
  </div>

  <!-- Login Button -->
  <button class="login-btn" id="loginBtn" onclick="document.getElementById('walletPanel').classList.add('show'); this.classList.add('hidden');">
    ğŸ¦„ Login / å‚åŠ ã™ã‚‹
  </button>

  <!-- Wallet Panel (hidden until login clicked) -->
  <div class="wallet-panel" id="walletPanel">
    <button class="wallet-close-btn" id="walletClose" onclick="this.parentElement.classList.remove('show'); document.getElementById('loginBtn').classList.remove('hidden');">âœ•</button>
    <div class="wallet-label" id="walletLabel">ğŸ¦„ Choose your name & connect wallet</div>
    <div id="walletForm">
      <input type="text" class="wallet-input" id="nameInput" placeholder="Display name (e.g. CryptoNinja)" maxlength="20" />
      <input type="text" class="wallet-input" id="walletInput" placeholder="SOL wallet address..." />
      <button class="wallet-join-btn" id="walletJoin">ğŸš€ Join the adventure!</button>
    </div>
    <div id="walletLoggedIn" style="display:none;">
      <div class="logged-in-info">
        <div class="logged-in-dot"></div>
        <div>
          <div class="logged-in-name" id="loggedInName">explorer</div>
          <div class="logged-in-wallet" id="loggedInWallet"></div>
        </div>
      </div>
      <button class="change-name-btn" id="changeNameBtn">change name</button>
    </div>
    <div class="wallet-status" id="walletStatus"></div>
  </div>

  <!-- Drawing Canvas Overlay -->
  <div class="canvas-overlay" id="canvasOverlay">
    <div class="canvas-prompt" id="canvasPrompt">...</div>
    <canvas class="draw-canvas" id="drawCanvas" width="800" height="800"></canvas>
    <div class="canvas-toolbar">
      <div class="canvas-tools">
        <button class="color-btn active" style="background:#000" data-color="#000"></button>
        <button class="color-btn" style="background:#333" data-color="#333333"></button>
        <button class="color-btn" style="background:#666" data-color="#666666"></button>
        <button class="color-btn" style="background:#999" data-color="#999999"></button>
        <button class="color-btn" style="background:#fff" data-color="#FFFFFF"></button>
        <button class="color-btn" style="background:#E84040" data-color="#E84040"></button>
        <button class="color-btn" style="background:#FF6B35" data-color="#FF6B35"></button>
        <button class="color-btn" style="background:#F4D06F" data-color="#F4D06F"></button>
        <button class="color-btn" style="background:#3A7D32" data-color="#3A7D32"></button>
        <button class="color-btn" style="background:#2ECDA7" data-color="#2ECDA7"></button>
        <button class="color-btn" style="background:#4A90D9" data-color="#4A90D9"></button>
        <button class="color-btn" style="background:#1A3A8A" data-color="#1A3A8A"></button>
        <button class="color-btn" style="background:#8B5CF6" data-color="#8B5CF6"></button>
        <button class="color-btn" style="background:#C5B8E8" data-color="#C5B8E8"></button>
        <button class="color-btn" style="background:#E8A0BF" data-color="#E8A0BF"></button>
        <button class="color-btn" style="background:#A0522D" data-color="#A0522D"></button>
        <button class="color-btn" style="background:#FFD4B8" data-color="#FFD4B8"></button>
        <button class="color-btn eraser-btn" data-color="eraser" title="Eraser">&#9003;</button>
      </div>
      <div class="brush-row">
        <span class="brush-row-label">size</span>
        <button class="size-btn active" data-size="2" title="Fine"><div class="size-dot" style="width:3px;height:3px"></div></button>
        <button class="size-btn" data-size="5" title="Small"><div class="size-dot" style="width:6px;height:6px"></div></button>
        <button class="size-btn" data-size="10" title="Medium"><div class="size-dot" style="width:10px;height:10px"></div></button>
        <button class="size-btn" data-size="18" title="Large"><div class="size-dot" style="width:14px;height:14px"></div></button>
        <button class="size-btn" data-size="30" title="Thicc"><div class="size-dot" style="width:18px;height:18px"></div></button>
        <span class="brush-row-label" style="margin-left:0.3rem">brush</span>
        <button class="brush-type-btn active" data-brush="round" title="Round brush">â— Round</button>
        <button class="brush-type-btn" data-brush="square" title="Square brush">â–  Square</button>
        <button class="brush-type-btn" data-brush="spray" title="Spray paint">â—Œ Spray</button>
      </div>
    </div>
    <div class="canvas-actions">
      <button class="task-btn secondary" id="canvasUndo" title="Undo last stroke">â†© æˆ»ã™ (undo)</button>
      <button class="task-btn secondary" id="canvasClear">æ¶ˆã™ (clear)</button>
      <button class="task-btn primary" id="canvasSubmit">&#10004; æå‡ºã™ã‚‹ (submit)</button>
      <button class="task-btn secondary" id="canvasClose">æˆ»ã‚‹ (back)</button>
    </div>
  </div>

  <!-- Global Chat Panel -->
  <div class="gchat-panel" id="gchatPanel">
    <div class="gchat-header">ğŸ’¬ Global Chat <span style="opacity:0.5;font-size:0.55rem">use @pippin to talk to Pippin</span></div>
    <div class="gchat-puzzle" id="gchatPuzzle" style="display:none">
      <div class="gchat-puzzle-title">ğŸ§© GROUP PUZZLE</div>
      <div class="gchat-puzzle-prompt" id="puzzlePrompt"></div>
      <div class="gchat-puzzle-bar-outer"><div class="gchat-puzzle-bar-inner" id="puzzleBar" style="width:0%"></div></div>
      <div class="gchat-puzzle-count" id="puzzleCount">0/5</div>
      <div class="gchat-puzzle-contribs" id="puzzleContribs"></div>
      <button class="gchat-puzzle-btn" id="puzzleContributeBtn" onclick="showPuzzleInput()">ğŸ¯ Contribute!</button>
    </div>
    <div class="gchat-messages" id="gchatMessages"></div>
    <div class="gchat-input-area">
      <input class="gchat-input" id="gchatInput" placeholder="Chat... or @pippin to talk to Pippin" maxlength="300" />
      <button class="gchat-send-btn" id="gchatSend" onclick="sendGlobalChat()">é€ä¿¡</button>
    </div>
  </div>
  <button class="gchat-toggle" id="gchatToggle" onclick="toggleChatPanel()">ğŸ’¬</button>

  <!-- Old Chat removed â€” now using Global Chat Panel -->

  <!-- Three.js via CDN -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
    import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ======================== SCENE SETUP ========================
    const canvas = document.getElementById('canvas3d');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
    renderer.shadowMap.enabled = !isMobile;  // Skip shadows on mobile for perf
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.9; // slightly muted for backrooms vibe
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    const scene = new THREE.Scene();
    // Backrooms-style atmosphere: muted pastel fog instead of bright sky
    scene.background = new THREE.Color(0xE8D5C4); // warm muted beige
    scene.fog = new THREE.FogExp2(0xE8D5C4, 0.015); // exponential fog - things fade into haze

    const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.set(0, 5, 12);

    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05; // smoother, dreamier movement
    controls.target.set(0, 1.2, 0);
    controls.minDistance = 2;
    controls.maxDistance = 60;
    controls.maxPolarAngle = Math.PI / 2 + 0.2;
    controls.autoRotate = false;
    controls.update();

    // ======================== LIGHTING (backrooms style) ========================
    // Dim ambient - like fluorescent lights in a liminal space
    const ambient = new THREE.AmbientLight(0xFFF0E0, 0.5);
    scene.add(ambient);

    // Key light - softer, slightly yellow like old fluorescents
    const sunLight = new THREE.DirectionalLight(0xFFF5D0, 1.0);
    sunLight.position.set(5, 12, 5);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.set(2048, 2048);
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 100;
    sunLight.shadow.camera.left = -20;
    sunLight.shadow.camera.right = 20;
    sunLight.shadow.camera.top = 20;
    sunLight.shadow.camera.bottom = -20;
    scene.add(sunLight);

    // Fill light - cool lavender, dimmer for backrooms vibe
    const fillLight = new THREE.DirectionalLight(0xB0A0D0, 0.3);
    fillLight.position.set(-3, 5, -3);
    scene.add(fillLight);

    // Subtle pink rim for Pippin's kawaii factor
    const rimLight = new THREE.DirectionalLight(0xE8A0BF, 0.2);
    rimLight.position.set(0, 3, -5);
    scene.add(rimLight);

    // ======================== LOADERS (declared early) ========================
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/libs/draco/');
    const gltfLoader = new GLTFLoader();
    gltfLoader.setDRACOLoader(dracoLoader);
    const fbxLoader = new FBXLoader();
    const loadingStatus = document.getElementById('loadingStatus');
    const loadingBar = document.getElementById('loadingBar');
    const loadingText = document.getElementById('loadingText');
    const loadingOverlayEl = document.getElementById('loadingOverlay');

    // Track loading progress: landscape(40%) + characters(30%) + unicorn(20%) + anims(10%)
    let loadProgress = { landscape: 0, characters: 0, unicorn: 0, anims: 0 };
    function updateLoadProgress(key, pct) {
      loadProgress[key] = pct;
      const weights = { landscape: 40, characters: 30, unicorn: 20, anims: 10 };
      const total = Object.keys(weights).reduce((sum, k) => sum + (loadProgress[k] / 100) * weights[k], 0);
      if (loadingBar) loadingBar.style.width = total + '%';
    }
    function setLoadText(text) {
      if (loadingStatus) loadingStatus.textContent = text;
      if (loadingText) loadingText.textContent = text;
    }
    function hideLoadingScreen() {
      if (loadingOverlayEl) loadingOverlayEl.classList.add('hidden');
      setTimeout(() => { if (loadingOverlayEl) loadingOverlayEl.style.display = 'none'; }, 600);
    }

    let unicornModel = null;
    let mixer = null; // unicorn animation mixer
    const sceneMixers = []; // landscape + character animation mixers
    const animations = {};
    let currentAction = null;

    // Bone name mapping: FBX Mixamo names -> Unicorn GLB bone names (with suffixes)
    const boneMap = {
      'mixamorig:Hips': 'mixamorig:Hips_01',
      'mixamorig:Spine': 'mixamorig:Spine_02',
      'mixamorig:Spine1': 'mixamorig:Spine1_03',
      'mixamorig:Spine2': 'mixamorig:Spine2_04',
      'mixamorig:Neck': 'mixamorig:Neck_05',
      'mixamorig:Head': 'mixamorig:Head_06',
      'mixamorig:HeadTop_End': 'mixamorig:HeadTop_End_07',
      'mixamorig:LeftShoulder': 'mixamorig:LeftShoulder_08',
      'mixamorig:LeftArm': 'mixamorig:LeftArm_09',
      'mixamorig:LeftForeArm': 'mixamorig:LeftForeArm_010',
      'mixamorig:LeftHand': 'mixamorig:LeftHand_011',
      'mixamorig:LeftHandIndex1': 'mixamorig:LeftHandIndex1_012',
      'mixamorig:LeftHandIndex2': 'mixamorig:LeftHandIndex2_013',
      'mixamorig:LeftHandIndex3': 'mixamorig:LeftHandIndex3_014',
      'mixamorig:LeftHandIndex4': 'mixamorig:LeftHandIndex4_015',
      'mixamorig:RightShoulder': 'mixamorig:RightShoulder_016',
      'mixamorig:RightArm': 'mixamorig:RightArm_017',
      'mixamorig:RightForeArm': 'mixamorig:RightForeArm_018',
      'mixamorig:RightHand': 'mixamorig:RightHand_019',
      'mixamorig:RightHandIndex1': 'mixamorig:RightHandIndex1_020',
      'mixamorig:RightHandIndex2': 'mixamorig:RightHandIndex2_021',
      'mixamorig:RightHandIndex3': 'mixamorig:RightHandIndex3_022',
      'mixamorig:RightHandIndex4': 'mixamorig:RightHandIndex4_023',
      'mixamorig:LeftUpLeg': 'mixamorig:LeftUpLeg_024',
      'mixamorig:LeftLeg': 'mixamorig:LeftLeg_025',
      'mixamorig:LeftFoot': 'mixamorig:LeftFoot_00',
      'mixamorig:LeftToeBase': 'mixamorig:LeftToeBase_026',
      'mixamorig:LeftToe_End': 'mixamorig:LeftToe_End_027',
      'mixamorig:RightUpLeg': 'mixamorig:RightUpLeg_028',
      'mixamorig:RightLeg': 'mixamorig:RightLeg_029',
      'mixamorig:RightFoot': 'mixamorig:RightFoot_030',
      'mixamorig:RightToeBase': 'mixamorig:RightToeBase_031',
      'mixamorig:RightToe_End': 'mixamorig:RightToe_End_032',
    };

    // Remap FBX animation tracks to match the unicorn's bone names
    function remapClip(clip) {
      clip.tracks.forEach(track => {
        // Track name format: "boneName.property" (e.g. "mixamorig:Hips.position")
        const dotIdx = track.name.indexOf('.');
        if (dotIdx === -1) return;
        const boneName = track.name.substring(0, dotIdx);
        const property = track.name.substring(dotIdx);
        if (boneMap[boneName]) {
          track.name = boneMap[boneName] + property;
        }
      });
      return clip;
    }

    // ======================== LOAD RIVER SCENE ========================
    let riverScene = null;

    // Debug display helper
    const debugEl = document.createElement('div');
    debugEl.style.cssText = 'position:fixed;bottom:130px;left:10px;z-index:999;background:rgba(0,0,0,0.8);color:#0f0;font:11px monospace;padding:8px 12px;border-radius:8px;max-width:550px;max-height:300px;overflow-y:auto;pointer-events:auto;display:none;';
    document.body.appendChild(debugEl);
    function dbg(msg) { debugEl.innerHTML += msg + '<br>'; debugEl.scrollTop = debugEl.scrollHeight; console.log(msg); }

    // ======================== LOAD SEQUENCE ========================
    // 1. Load original landscape (river, mountains, mushrooms)
    // 2. Load v2 (characters)
    // 3. Load unicorn into the bathtub

    let landscapeBox = null;

    setLoadText('Loading river landscape desu...');
    gltfLoader.load('models/lysergic_river.glb', (gltf) => {
      riverScene = gltf.scene;
      updateLoadProgress('landscape', 100);

      const box = new THREE.Box3().setFromObject(riverScene);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());
      landscapeBox = box;

      dbg(`Landscape size: ${size.x.toFixed(1)} x ${size.y.toFixed(1)} x ${size.z.toFixed(1)}`);
      dbg(`Landscape center: ${center.x.toFixed(1)}, ${center.y.toFixed(1)}, ${center.z.toFixed(1)}`);

      // Find bathtub by searching for key names: "bathtub", "Dummy018", "Object005"
      let landscapeBathtub = null;
      let dummy018 = null;
      riverScene.traverse((child) => {
        if (child.isMesh) {
          child.receiveShadow = true;
          child.castShadow = true;
        }
        if (!child.name) return;
        const n = child.name.toLowerCase();

        // Log ALL named non-mesh nodes for debugging (groups, bones, dummies)
        if (!child.isMesh && child.name && child.children.length > 0) {
          const wp = new THREE.Vector3();
          child.getWorldPosition(wp);
          if (n.includes('dummy') || n.includes('bathtub') || n.includes('object')) {
            dbg(`  NODE: "${child.name}" type:${child.type} pos:(${wp.x.toFixed(1)},${wp.y.toFixed(1)},${wp.z.toFixed(1)}) children:${child.children.length}`);
          }
        }

        // Find Dummy018 - this is the animated node that drives the bathtub along the river
        if (child.name === 'Dummy018' && !dummy018) {
          dummy018 = child;
          const wp = new THREE.Vector3();
          child.getWorldPosition(wp);
          dbg(`>>> Found Dummy018 at world (${wp.x.toFixed(1)},${wp.y.toFixed(1)},${wp.z.toFixed(1)})`);
        }

        // Also look for explicit bathtub nodes
        if (n.includes('bathtub') && !landscapeBathtub) {
          landscapeBathtub = child;
          const wp = new THREE.Vector3();
          child.getWorldPosition(wp);
          let chain = child.name;
          let p = child.parent;
          while (p && p !== riverScene) { chain = p.name + ' > ' + chain; p = p.parent; }
          dbg(`>>> Found bathtub: "${child.name}" chain: ${chain} pos:(${wp.x.toFixed(1)},${wp.y.toFixed(1)},${wp.z.toFixed(1)})`);
        }
      });

      // Priority: Dummy018 > explicit bathtub mesh > nothing
      // Dummy018 is the animation-driven parent that carries the bathtub along the river
      if (dummy018) {
        landscapeBathtub = dummy018;
        dbg(`>>> Using Dummy018 as bathtub tracker`);
      } else if (landscapeBathtub) {
        dbg(`>>> Using bathtub node: "${landscapeBathtub.name}"`);
      } else {
        dbg(`>>> WARNING: No bathtub or Dummy018 found!`);
      }

      // Log all top-level children + meshes with "river" or "water" in the name
      dbg('--- landscape children ---');
      riverScene.children.forEach(c => {
        dbg(`  landscape child: "${c.name}" type:${c.type}`);
      });
      // Find and fix the rainbow river water (C20H25N3O material)
      let waterMeshCount = 0;
      riverScene.traverse((child) => {
        const n = (child.name || '').toLowerCase();
        const matName = (child.material && child.material.name) ? child.material.name : '';

        if (matName === 'C20H25N3O' || n.includes('c20h25n3o')) {
          dbg(`  RIVER WATER: "${child.name}" type:${child.type} visible:${child.visible} mat:${matName}`);
          waterMeshCount++;
          child.visible = true;
          if (child.isMesh && child.material) {
            const mat = child.material;
            dbg(`    mat type:${mat.type} transparent:${mat.transparent} opacity:${mat.opacity}`);
            // Ensure it renders on top of terrain
            mat.side = THREE.DoubleSide;
            mat.depthWrite = true;
            child.renderOrder = 1; // render after terrain (default is 0)
            mat.needsUpdate = true;
          }
        }

        // Also log Rainbow material objects
        if (matName === 'Rainbow' || n.includes('rainbow')) {
          if (!n.includes('cloud')) { // don't log every cloud
            dbg(`  RAINBOW: "${child.name}" visible:${child.visible}`);
          }
          child.visible = true;
        }
      });
      dbg(`Total river water objects: ${waterMeshCount}`);

      // PLAY BUILT-IN ANIMATIONS from the landscape GLB
      // But FILTER OUT translation tracks from Dummy/CAT nodes so characters
      // dance in place instead of orbiting around the scene.
      // Keep: bathtub movement, character limb rotation (dancing), environment rotation.
      // Remove: Dummy*/CAT_* translation (which orbits characters around).
      if (gltf.animations && gltf.animations.length > 0) {
        dbg(`Landscape has ${gltf.animations.length} animations!`);
        const landscapeMixer = new THREE.AnimationMixer(riverScene);
        sceneMixers.push(landscapeMixer);

        gltf.animations.forEach((clip, i) => {
          const originalTrackCount = clip.tracks.length;

          // WHITELIST: only specific nodes may translate.
          // Everything else keeps rotation/scale but NOT translation.
          // Only the bathtub boat should move through the scene.
          const filteredTracks = clip.tracks.filter(track => {
            const isTranslation = track.name.endsWith('.position');
            if (!isTranslation) return true; // keep all rotation/scale tracks

            const nodeName = track.name.split('.')[0];

            // 1. Bathtub + parent Dummy018 (boat floats down river)
            if (nodeName === 'Dummy018' || nodeName.toLowerCase().includes('bathtub') ||
                nodeName.includes('Object005')) return true;

            // 2. CATRig skeleton bones (actual limb movement for dancing)
            if (nodeName.startsWith('CATRig')) return true;

            // 3. Pastisympaty body parts
            if (nodeName.startsWith('Pastisympaty_')) return true;

            // 4. PastyFly wings
            if (nodeName.includes('PastyFly_wing')) return true;

            // BLOCK everything else (FlowCAT, CATWORM, Smoke, Dummy, CAT_, etc.)
            return false;
          });

          // Create a new clip with only the filtered tracks
          const newClip = new THREE.AnimationClip(clip.name, clip.duration, filteredTracks);
          const removed = originalTrackCount - filteredTracks.length;
          dbg(`  anim[${i}]: "${clip.name}" ${filteredTracks.length} tracks (removed ${removed} orbit translations)`);

          const action = landscapeMixer.clipAction(newClip);
          action.play();
        });
      } else {
        dbg('Landscape: no built-in animations');
      }

      scene.add(riverScene);

      // Now load v2 (characters) on top
      loadCharacters(center, box);
    },
    (progress) => {
      if (progress.total > 0) {
        const pct = Math.round((progress.loaded / progress.total) * 100);
        setLoadText(`Loading landscape... ${pct}%`);
        updateLoadProgress('landscape', pct);
      }
    },
    (error) => {
      dbg('Landscape failed: ' + error.message);
      setLoadText('landscape failed, trying characters desu...');
      updateLoadProgress('landscape', 100);
      loadCharacters(new THREE.Vector3(0, 0, 0), null);
    });

    function loadCharacters(landscapeCenter, lBox) {
      setLoadText('Loading characters desu...');
      gltfLoader.load('models/lysergic_v2.glb', (gltf) => {
        const charScene = gltf.scene;

        const charBox = new THREE.Box3().setFromObject(charScene);
        const charCenter = charBox.getCenter(new THREE.Vector3());
        const charSize = charBox.getSize(new THREE.Vector3());
        dbg(`Characters size: ${charSize.x.toFixed(1)} x ${charSize.y.toFixed(1)} x ${charSize.z.toFixed(1)}`);
        dbg(`Characters center: ${charCenter.x.toFixed(1)}, ${charCenter.y.toFixed(1)}, ${charCenter.z.toFixed(1)}`);

        // Align v2 to landscape if both have bounding boxes
        if (lBox) {
          const lCenter = lBox.getCenter(new THREE.Vector3());
          const offset = new THREE.Vector3().subVectors(lCenter, charCenter);
          // Only align XZ (horizontal), keep Y as-is to avoid floating
          charScene.position.x += offset.x;
          charScene.position.z += offset.z;
          dbg(`Aligned chars: offset X=${offset.x.toFixed(1)} Z=${offset.z.toFixed(1)}`);
        }

        // Remove duplicate bathtub from v2 (the landscape already has one)
        const toRemove = [];
        charScene.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
          if (child.name) {
            const n = child.name.toLowerCase();
            if (n.includes('bathtub') || n.includes('bath_') || n.includes('tub')) {
              toRemove.push(child);
            }
          }
        });
        toRemove.forEach(obj => {
          if (obj.parent) obj.parent.remove(obj);
          dbg(`Removed duplicate: "${obj.name}"`);
        });

        // Remove DUPLICATE meshes from v2 that already exist in the landscape.
        // v2 has overlapping Spun, C20H25N3O (river), terrain, etc.
        // We ONLY want the unique characters/animations from v2.
        const v2DupeRemove = [];
        const v2KeptMeshes = [];
        charScene.traverse((child) => {
          if (!child.isMesh) return;
          const n = (child.name || '').toLowerCase();
          const matName = (child.material && child.material.name) ? child.material.name.toLowerCase() : '';

          // Keep character-related meshes (pastisympaty, mushrooman, worm, pastefly, etc.)
          // Remove terrain/environment duplicates (spun, land, c20h25n3o, rainbow, dome, pipe, hand, carousel, etc.)
          const isCharacter = matName.includes('pastisympaty') || matName.includes('mushrooman') ||
                              matName.includes('worm') || matName.includes('pastyfly') ||
                              matName.includes('turkey') || matName.includes('syringe') ||
                              matName.includes('flower') || matName.includes('pasti') ||
                              n.includes('pastisympaty') || n.includes('mushrooman') ||
                              n.includes('worm') || n.includes('pastyfly') ||
                              n.includes('turkey') || n.includes('syringe');

          if (!isCharacter) {
            // This is environment/terrain - check if it duplicates the landscape
            const isDupe = matName.includes('spun') || matName.includes('c20h25n3o') ||
                          matName.includes('rainbow') || matName.includes('pipe') ||
                          matName.includes('hand') || matName.includes('ovni') ||
                          matName.includes('carousel') || matName.includes('gillet') ||
                          matName.includes('elastic') || matName.includes('mushroomtree') ||
                          matName.includes('billetin') || matName.includes('creditcard') ||
                          matName.includes('pastiswings') || matName.includes('bathtub') ||
                          matName.includes('dome') || matName.includes('cylinder') ||
                          n.includes('spun') || n.includes('c20h25n3o');
            if (isDupe) {
              v2DupeRemove.push(child);
            } else {
              v2KeptMeshes.push(child.name || 'unnamed');
            }
          } else {
            v2KeptMeshes.push(child.name || 'unnamed');
          }
        });
        v2DupeRemove.forEach(obj => {
          if (obj.parent) obj.parent.remove(obj);
        });
        dbg(`v2: removed ${v2DupeRemove.length} duplicate meshes, kept ${v2KeptMeshes.length}`);
        if (v2KeptMeshes.length <= 20) {
          v2KeptMeshes.forEach(n => dbg(`  kept: ${n}`));
        }

        // PLAY v2 ANIMATIONS - same filtering: remove orbit translations from Dummy/CAT nodes
        if (gltf.animations && gltf.animations.length > 0) {
          dbg(`Characters have ${gltf.animations.length} animations!`);
          const charMixer = new THREE.AnimationMixer(charScene);
          sceneMixers.push(charMixer);
          gltf.animations.forEach((clip, i) => {
            // Same whitelist filter as landscape
            const filteredTracks = clip.tracks.filter(track => {
              const isTranslation = track.name.endsWith('.position');
              if (!isTranslation) return true;
              const nodeName = track.name.split('.')[0];
              if (nodeName === 'Dummy018' || nodeName.toLowerCase().includes('bathtub')) return true;
              if (nodeName.startsWith('CATRig')) return true;
              if (nodeName.startsWith('Pastisympaty_')) return true;
              if (nodeName.includes('PastyFly_wing')) return true;
              return false; // block all other translations
            });
            const newClip = new THREE.AnimationClip(clip.name, clip.duration, filteredTracks);
            const removed = clip.tracks.length - filteredTracks.length;
            dbg(`  char anim[${i}]: "${clip.name}" ${filteredTracks.length} tracks (removed ${removed} orbits)`);
            const action = charMixer.clipAction(newClip);
            action.play();
          });
        } else {
          dbg('Characters: no built-in animations');
        }

        scene.add(charScene);

        // Load unicorn last - use the landscape bathtub
        setLoadText('Loading unicorn desu...');
        updateLoadProgress('characters', 100);
        loadUnicorn(charCenter, charBox, landscapeBathtub, []);
      },
      (progress) => {
        if (progress.total > 0) {
          const pct = Math.round((progress.loaded / progress.total) * 100);
          setLoadText(`Loading characters... ${pct}%`);
          updateLoadProgress('characters', pct);
        }
      },
      (error) => {
        dbg('Characters failed: ' + error.message);
        updateLoadProgress('characters', 100);
        loadUnicorn(landscapeCenter, lBox, null, []);
      });
    }

    // Store bathtub ref globally for animation
    let bathtubRef = null;

    // ======================== VIEW MODE ========================
    let isFirstPerson = false;
    let savedCamPos = null;
    let savedCamTarget = null;

    // ======================== AUTO-DANCE ========================
    let autoDanceActive = false;
    let autoDanceTimer = null;
    const danceAnims = ['builtin', 'idle', 'walking', 'jump', 'samba', 'gangnam', 'backflip'];

    function startAutoDance() {
      autoDanceActive = true;
      pickRandomDance();
    }

    function stopAutoDance() {
      autoDanceActive = false;
      if (autoDanceTimer) clearTimeout(autoDanceTimer);
      autoDanceTimer = null;
    }

    function pickRandomDance() {
      if (!autoDanceActive) return;
      // Pick a random animation that's loaded
      const available = danceAnims.filter(n => animations[n]);
      if (available.length === 0) return;
      const pick = available[Math.floor(Math.random() * available.length)];
      playAnimation(pick);
      // Schedule next switch in 4-10 seconds
      const delay = 4000 + Math.random() * 6000;
      autoDanceTimer = setTimeout(pickRandomDance, delay);
    }

    // Container that sits in the bathtub; unicorn model goes inside.
    // Animations move the inner model but the container holds the bathtub offset.
    let unicornContainer = null;

    // Make animation clips "in-place": zero out the root Hips position track
    // so the dance happens at the model's origin instead of at the Mixamo baked absolute position.
    function makeClipInPlace(clip) {
      clip.tracks.forEach(track => {
        if (track.name.includes('Hips') && track.name.endsWith('.position')) {
          dbg(`  Zeroing root motion: "${track.name}" (${track.values.length / 3} keyframes)`);
          const vals = track.values;
          const baseX = vals[0], baseY = vals[1], baseZ = vals[2];
          dbg(`    Original hips base: ${baseX.toFixed(1)}, ${baseY.toFixed(1)}, ${baseZ.toFixed(1)}`);
          for (let i = 0; i < vals.length; i += 3) {
            vals[i]     -= baseX;
            vals[i + 1] -= baseY;
            vals[i + 2] -= baseZ;
          }
          dbg(`    Hips now relative around (0, 0, 0)`);
        }
      });
      return clip;
    }

    // Unicorn loading function - called after river loads
    function loadUnicorn(sceneCenter, sceneBBox, bathtub, candidates) {
      const UNICORN_URL = 'https://wgpnbnvlbnilfxqcexht.supabase.co/storage/v1/object/public/assets/models/kawaii_unicorn_rigged.glb';
      gltfLoader.load(UNICORN_URL, (gltf) => {
        unicornModel = gltf.scene;

        // Measure the unicorn at original scale
        const unicornBox = new THREE.Box3().setFromObject(unicornModel);
        const unicornSize = unicornBox.getSize(new THREE.Vector3());
        const unicornCenter = unicornBox.getCenter(new THREE.Vector3());
        dbg(`Unicorn raw size: ${unicornSize.x.toFixed(2)} x ${unicornSize.y.toFixed(2)} x ${unicornSize.z.toFixed(2)}`);
        dbg(`Unicorn raw center: ${unicornCenter.x.toFixed(2)}, ${unicornCenter.y.toFixed(2)}, ${unicornCenter.z.toFixed(2)}`);

        // Use the bathtub reference for tracking
        if (bathtub) {
          bathtubRef = bathtub;
          const wp = new THREE.Vector3();
          bathtub.getWorldPosition(wp);
          dbg(`Bathtub ref: "${bathtub.name}" world:(${wp.x.toFixed(1)},${wp.y.toFixed(1)},${wp.z.toFixed(1)})`);
        }

        let tubWorldPos = sceneCenter.clone();
        if (bathtubRef) {
          bathtubRef.getWorldPosition(tubWorldPos);
        }

        // Scale unicorn to a FIXED reasonable size relative to the scene
        // The landscape is typically ~100 units wide, bathtub is ~2-3 units
        // Set unicorn to about 1.5 units tall
        const targetHeight = 1.5;
        const scaleFactor = targetHeight / unicornSize.y;
        unicornModel.scale.set(scaleFactor, scaleFactor, scaleFactor);

        dbg(`Unicorn scale: ${scaleFactor.toFixed(4)}, target height: ${targetHeight}`);

        // Add unicorn to scene root - user can walk/fly it anywhere
        unicornContainer = new THREE.Group();
        unicornContainer.name = 'unicornContainer';
        unicornModel.position.set(0, 0, 0);
        unicornContainer.add(unicornModel);
        scene.add(unicornContainer);

        // Place at the scene center, slightly above the landscape
        const startPos = sceneCenter.clone();
        startPos.y += 2; // start floating a bit above ground
        unicornContainer.position.copy(startPos);
        dbg(`Unicorn placed at: (${startPos.x.toFixed(1)}, ${startPos.y.toFixed(1)}, ${startPos.z.toFixed(1)}) - free roam!`);

        // Enable shadows
        unicornModel.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });

        // Log skeleton bones for animation debug
        unicornModel.traverse((child) => {
          if (child.isSkinnedMesh) {
            dbg(`Skinned mesh: ${child.name}, bones: ${child.skeleton.bones.length}`);
            child.skeleton.bones.slice(0, 5).forEach(b => dbg(`  bone: ${b.name}`));
          }
        });

        // Create animation mixer for the unicorn
        mixer = new THREE.AnimationMixer(unicornModel);

        // Load built-in GLB animations (the unicorn has a Gangnam Style baked in!)
        if (gltf.animations && gltf.animations.length > 0) {
          dbg(`Unicorn GLB has ${gltf.animations.length} built-in anims`);
          gltf.animations.forEach((clip) => {
            dbg(`  GLB anim: "${clip.name}" tracks:${clip.tracks.length} dur:${clip.duration.toFixed(1)}s`);
            clip.tracks.slice(0, 5).forEach(t => dbg(`    track: ${t.name}`));

            // Make the dance in-place before creating the action
            makeClipInPlace(clip);

            const action = mixer.clipAction(clip);
            animations['builtin'] = action;
            animations['gangnam'] = action;
            animations['idle'] = action;
          });

          // IMMEDIATELY play the built-in animation
          const builtinAction = animations['builtin'];
          if (builtinAction) {
            builtinAction.reset().play();
            builtinAction.setLoop(THREE.LoopRepeat);
            currentAction = builtinAction;
            dbg('Playing built-in animation NOW!');
          }
        } else {
          dbg('Unicorn: NO built-in animations!');
        }

        // Camera: look at the unicorn
        const camTarget = unicornContainer.position.clone();
        camTarget.y += 0.5;
        controls.target.copy(camTarget);
        camera.position.set(camTarget.x - 4, camTarget.y + 3, camTarget.z + 6);
        controls.update();

        dbg(`Camera targeting unicorn at: ${camTarget.x.toFixed(1)},${camTarget.y.toFixed(1)},${camTarget.z.toFixed(1)}`);

        // Now try loading FBX animations (will override if they work)
        loadFBXAnimations();
      },
      (progress) => {
        if (progress.total > 0) {
          const pct = Math.round((progress.loaded / progress.total) * 100);
          setLoadText(`Loading unicorn... ${pct}%`);
          updateLoadProgress('unicorn', pct);
        }
      },
      (error) => {
        console.error('Error loading unicorn:', error);
        setLoadText('error loading unicorn desu :(');
      });
    }

    // ======================== FBX ANIMATION LOADING ========================
    const animFiles = {
      idle: 'https://wgpnbnvlbnilfxqcexht.supabase.co/storage/v1/object/public/assets/animations/idle.fbx',
      walking: 'https://wgpnbnvlbnilfxqcexht.supabase.co/storage/v1/object/public/assets/animations/walking.fbx',
      jump: 'https://wgpnbnvlbnilfxqcexht.supabase.co/storage/v1/object/public/assets/animations/jump.fbx',
      samba: 'https://wgpnbnvlbnilfxqcexht.supabase.co/storage/v1/object/public/assets/animations/samba_dancing.fbx',
      gangnam: 'https://wgpnbnvlbnilfxqcexht.supabase.co/storage/v1/object/public/assets/animations/Gangnam_Style.fbx',
      backflip: 'https://wgpnbnvlbnilfxqcexht.supabase.co/storage/v1/object/public/assets/animations/back_flip_to_uppercut.fbx',
    };

    let loadedAnims = 0;
    const totalAnims = Object.keys(animFiles).length;

    function loadFBXAnimations() {
      setLoadText('Loading animations desu...');

      Object.entries(animFiles).forEach(([name, filePath]) => {
        fbxLoader.load(filePath, (fbx) => {
          if (fbx.animations && fbx.animations.length > 0) {
            const clip = fbx.animations[0];
            clip.name = name;

            // Log raw track names BEFORE remapping
            if (clip.tracks.length > 0) {
              dbg(`FBX "${name}" raw tracks[0]: ${clip.tracks[0].name}`);
            }

            // Remap bone names to match the unicorn's skeleton
            remapClip(clip);
            // Make dance in-place (zero out root hips translation)
            makeClipInPlace(clip);

            // Log AFTER remapping
            if (clip.tracks.length > 0) {
              dbg(`FBX "${name}" remapped[0]: ${clip.tracks[0].name}`);
            }

            // Check how many tracks actually match a bone in the unicorn
            let matched = 0, unmatched = 0;
            const unmatchedNames = [];
            clip.tracks.forEach(t => {
              const boneName = t.name.split('.')[0];
              if (unicornModel.getObjectByName(boneName)) {
                matched++;
              } else {
                unmatched++;
                if (unmatchedNames.length < 3) unmatchedNames.push(boneName);
              }
            });

            dbg(`FBX "${name}": ${clip.tracks.length} tracks, ${matched} matched, ${unmatched} unmatched`);
            if (unmatchedNames.length > 0) {
              dbg(`  unmatched sample: ${unmatchedNames.join(', ')}`);
            }

            // Only use this animation if it has matches
            if (matched > 0) {
              const action = mixer.clipAction(clip);
              animations[name] = action;
            }
          } else {
            dbg(`FBX "${name}": no animations found`);
          }

          loadedAnims++;
          setLoadText(`Loading animations... ${loadedAnims}/${totalAnims}`);
          updateLoadProgress('anims', Math.round((loadedAnims / totalAnims) * 100));
          if (loadedAnims >= totalAnims) onAllLoaded();
        },
        undefined,
        (error) => {
          dbg(`FBX "${name}" FAILED: ${error.message || error}`);
          loadedAnims++;
          if (loadedAnims >= totalAnims) onAllLoaded();
        });
      });
    }

    function onAllLoaded() {
      console.log('All animations loaded:', Object.keys(animations));
      dbg(`Loaded anims: ${Object.keys(animations).join(', ')}`);

      // Start with idle animation (not dancing)
      if (animations.idle && currentAction !== animations.idle) {
        playAnimation('idle');
        dbg('Started idle animation (not dancing)');
      } else if (animations.builtin && !currentAction) {
        playAnimation('builtin');
        dbg('Fallback: started built-in animation');
      }

      // Hide loading screen
      updateLoadProgress('anims', 100);
      setLoadText('Ready desu!');
      setTimeout(() => {
        hideLoadingScreen();
      }, 500);
    }

    // ======================== ANIMATION CONTROL ========================
    function playAnimation(name) {
      const action = animations[name];
      if (!action) {
        dbg(`Animation "${name}" not found, available: ${Object.keys(animations).join(', ')}`);
        return;
      }

      if (currentAction && currentAction !== action) {
        currentAction.fadeOut(0.3);
      }

      action.reset().fadeIn(0.3).play();

      // For one-shot animations, go back to idle/next dance after
      if (name === 'jump' || name === 'backflip') {
        action.setLoop(THREE.LoopOnce);
        action.clampWhenFinished = false;
        mixer.addEventListener('finished', function onFinished(e) {
          if (e.action === action) {
            mixer.removeEventListener('finished', onFinished);
            if (autoDanceActive) {
              pickRandomDance();
            } else {
              playAnimation('idle');
            }
          }
        });
      } else {
        action.setLoop(THREE.LoopRepeat);
      }

      currentAction = action;

    }

    // ======================== HAPPY DANCE (triggered by task approval) ========================
    let happyDanceTimer = null;
    const celebrationAnims = ['samba', 'gangnam', 'backflip', 'walking'];

    function triggerHappyDance() {
      // Pick a fun dance animation
      const available = celebrationAnims.filter(n => animations[n]);
      if (available.length === 0) return;
      const pick = available[Math.floor(Math.random() * available.length)];
      playAnimation(pick);

      // Return to idle after 4-6 seconds
      if (happyDanceTimer) clearTimeout(happyDanceTimer);
      happyDanceTimer = setTimeout(() => {
        if (!isSpeaking) {
          playAnimation(animations.idle ? 'idle' : 'builtin');
        }
        happyDanceTimer = null;
      }, 4000 + Math.random() * 2000);
    }

    // ======================== DOC POPUP ========================
    document.getElementById('introInfoBtn').addEventListener('click', () => {
      document.getElementById('docOverlay').classList.add('show');
    });
    document.getElementById('docClose').addEventListener('click', () => {
      document.getElementById('docOverlay').classList.remove('show');
    });

    // CA copy-to-clipboard on click (prevent navigation, copy instead)
    const CA = '4srVZphD4XnXmV2iGs2diQs644Po7njkBBU4wdZspump';
    document.querySelectorAll('.ca-link, .ca-header').forEach(el => {
      el.addEventListener('click', (e) => {
        e.preventDefault();
        navigator.clipboard.writeText(CA).then(() => {
          const orig = el.textContent;
          el.textContent = 'Copied! âœ“';
          el.style.color = '#66bb6a';
          setTimeout(() => { el.textContent = orig; el.style.color = ''; }, 1500);
        }).catch(() => {
          window.open(el.href, '_blank');
        });
      });
    });
    document.getElementById('docOverlay').addEventListener('click', (e) => {
      if (e.target === document.getElementById('docOverlay')) {
        document.getElementById('docOverlay').classList.remove('show');
      }
    });

    // Help button (in-game)
    document.getElementById('helpBtn').addEventListener('click', () => {
      document.getElementById('helpOverlay').classList.add('show');
    });
    document.getElementById('helpClose').addEventListener('click', () => {
      document.getElementById('helpOverlay').classList.remove('show');
    });
    document.getElementById('helpOverlay').addEventListener('click', (e) => {
      if (e.target === document.getElementById('helpOverlay')) {
        document.getElementById('helpOverlay').classList.remove('show');
      }
    });

    // ======================== GALLERY POPUP ========================
    document.getElementById('galleryBtn').addEventListener('click', () => {
      document.getElementById('galleryOverlay').classList.add('show');
      loadGallery();
    });
    document.getElementById('galleryClose').addEventListener('click', () => {
      document.getElementById('galleryOverlay').classList.remove('show');
    });
    document.getElementById('galleryOverlay').addEventListener('click', (e) => {
      if (e.target === document.getElementById('galleryOverlay')) {
        document.getElementById('galleryOverlay').classList.remove('show');
      }
    });

    async function loadGallery() {
      const grid = document.getElementById('galleryGrid');
      grid.innerHTML = '<div class="gallery-empty">Loading drawings desu...</div>';
      try {
        const res = await fetch('/api/drawings');
        const drawings = await res.json();
        if (!drawings || drawings.length === 0) {
          grid.innerHTML = '<div class="gallery-empty">No drawings yet ne... be the first to draw desu! ğŸ¨</div>';
          return;
        }
        grid.innerHTML = '';
        drawings.forEach(d => {
          const card = document.createElement('div');
          card.className = 'gallery-card';
          const timeAgo = getTimeAgo(new Date(d.created_at));
          const prompt = d.prompt || 'free draw';
          const tweetText = encodeURIComponent(
            `Pippin asked me to "${prompt}" and I delivered ne! ğŸ¨ğŸ¦„\n\nPippin's Groundhog Day â€” an AI unicorn trapped in a time loop desu\n\nCA: 4srVZphD4XnXmV2iGs2diQs644Po7njkBBU4wdZspump\n\npippingroundhog.com`
          );
          const tweetUrl = `https://twitter.com/intent/tweet?text=${tweetText}`;
          const liked = localStorage.getItem('liked_' + d.id);
          card.innerHTML = `
            <img src="${d.image_data}" alt="${prompt}" loading="lazy" />
            <div class="gallery-card-info">
              <div class="gallery-prompt">${prompt}</div>
              <div class="gallery-artist">by ${d.artist} ${d.wallet ? '(' + d.wallet + ')' : ''}</div>
              <div class="gallery-time">${timeAgo}</div>
              <div class="gallery-actions">
                <button class="gallery-like ${liked ? 'liked' : ''}" data-id="${d.id}" onclick="likeDrawing(this, '${d.id}')">
                  â™¥ <span class="gallery-like-count">${d.likes || 0}</span>
                </button>
                <a class="gallery-share" href="${tweetUrl}" target="_blank" rel="noopener" style="margin-top:0;">
                  <svg viewBox="0 0 24 24"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
                  Share
                </a>
              </div>
            </div>
          `;
          grid.appendChild(card);
        });
      } catch (e) {
        grid.innerHTML = '<div class="gallery-empty">Error loading gallery desu :(</div>';
      }
    }

    function getTimeAgo(date) {
      const seconds = Math.floor((Date.now() - date.getTime()) / 1000);
      if (seconds < 60) return 'just now';
      if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
      if (seconds < 86400) return Math.floor(seconds / 3600) + 'h ago';
      return Math.floor(seconds / 86400) + 'd ago';
    }

    // ======================== RANKING POPUP ========================
    document.getElementById('rankingBtn').addEventListener('click', () => {
      document.getElementById('rankingOverlay').classList.add('show');
      loadRanking();
    });
    document.getElementById('rankingClose').addEventListener('click', () => {
      document.getElementById('rankingOverlay').classList.remove('show');
    });
    document.getElementById('rankingOverlay').addEventListener('click', (e) => {
      if (e.target === document.getElementById('rankingOverlay')) {
        document.getElementById('rankingOverlay').classList.remove('show');
      }
    });

    async function loadRanking() {
      const listEl = document.getElementById('rankingList');
      const metaEl = document.getElementById('rankingMeta');
      listEl.innerHTML = '<div class="ranking-loading">èª­ã¿è¾¼ã¿ä¸­...</div>';
      metaEl.textContent = '';

      try {
        const res = await fetch('/api/ranking');
        const data = await res.json();

        metaEl.textContent = `Life #${data.life || 1} Â· ${data.total || 0} participants`;

        if (!data.players || data.players.length === 0) {
          listEl.innerHTML = '<div class="ranking-loading">ã¾ã å‚åŠ è€…ãŒã„ã¾ã›ã‚“ / No participants yet</div>';
          return;
        }

        listEl.innerHTML = data.players.map(p => {
          const isMe = myWallet && p.wallet === myWallet;
          return `<div class="rank-row${isMe ? ' me' : ''}">
            <div class="rank-pos">${p.rank <= 3 ? ['ğŸ¥‡','ğŸ¥ˆ','ğŸ¥‰'][p.rank-1] : '#' + p.rank}</div>
            <div class="rank-wallet" style="word-break:break-all;font-size:0.6rem">${p.wallet}</div>
            <div class="rank-stats">
              <div class="rank-stat"><div class="rank-stat-val">${p.tasks}</div><div class="rank-stat-label">tasks</div></div>
              <div class="rank-stat"><div class="rank-stat-val">${p.happiness}</div><div class="rank-stat-label">happy</div></div>
              <div class="rank-stat"><div class="rank-stat-val">${p.entries}</div><div class="rank-stat-label">entries</div></div>
            </div>
          </div>`;
        }).join('');
      } catch (e) {
        listEl.innerHTML = '<div class="ranking-loading">ã‚¨ãƒ©ãƒ¼ / Error loading ranking</div>';
      }
    }

    // ======================== INTRO + MUSIC ========================
    const bgMusic = document.getElementById('bgMusic');
    bgMusic.volume = 0.3;
    let hasEntered = false;
    let currentHappiness = 0;

    document.getElementById('introEnter').addEventListener('click', () => {
      if (hasEntered) return;
      hasEntered = true;

      // Start music
      bgMusic.play().catch(e => console.warn('Music autoplay blocked:', e));

      // Fade out intro
      document.getElementById('introOverlay').classList.add('hidden');

      // Lower music volume when Pippin speaks
      dbg('Entered the backrooms. Music playing.');
    });

    // Duck music when TTS is playing
    function duckMusic() {
      if (bgMusic) bgMusic.volume = 0.08;
    }
    function unduckMusic() {
      if (bgMusic) bgMusic.volume = 0.3;
    }

    // View toggle removed â€” always orbit mode

    // ======================== SPEECH / CHAT with TTS ========================
    const speechBubble = document.getElementById('speechBubble');
    let isSpeaking = false;
    let currentAudio = null;
    let ttsAbortController = null;
    let speechIdCounter = 0;

    // Fallback responses (jp/en pairs)
    const pippinResponses = [
      { jp: "ãˆãƒ¼ã£ã€è©±ã—ã‹ã‘ã¦ãã‚ŒãŸã®ï¼Ÿã™ã”ã„ï¼ä»Šãƒ„ãƒãŒå…‰ã£ã¦ã‚‹ã‚ˆã€ãƒã‚¸ã§ã‚·ã‚°ãƒã ã­ï¼", en: "wait you're talking to me? amazing! my horn is literally glowing right now, that's so sigma!" },
      { jp: "ã¡ã‚‡ã£ã¨å¾…ã£ã¦ã€ã¾ãŸãƒªã‚¹ãƒãƒ¼ãƒ³ã—ã¡ã‚ƒã£ãŸã‹ã‚‰ã€ãªã‚“ã§ãƒã‚¹ã‚¿ãƒ–ã«ã„ã‚‹ã‹å¿˜ã‚Œã¡ã‚ƒã£ãŸã€‚ã¾ã‚ã„ã„ã‹ã€‚", en: "hold on, I just respawned and forgot why I'm in a bathtub again. whatever, this is fine." },
      { jp: "ã­ãˆã­ãˆã€ã“ã®å·ã£ã¦ãƒ¡ã‚¿ãƒãƒ¼ã‚¹ãã®ã‚‚ã®ã˜ã‚ƒãªã„ï¼Ÿã¿ã‚“ãªã·ã‹ã·ã‹æµ®ã„ã¦ãƒã‚¤ãƒ–ã‚¹ã—ã¦ã‚‹ã—ã€ã™ã”ããªã„ï¼Ÿ", en: "hey hey, what if this river IS the metaverse? we're all just floating and vibing in it, right?" },
      { jp: "ç§ã€æ–‡å­—é€šã‚Šãƒã‚¹ã‚¿ãƒ–ã«ä¹—ã£ãŸãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ³ãŒã‚µã‚¤ã‚±ãƒ‡ãƒªãƒƒã‚¯ãªå·ã‚’æµã‚Œã¦ã‚‹ã‚“ã ã‘ã©ã€‚æœ€é«˜ã®äººç”Ÿã˜ã‚ƒã‚“ï¼", en: "I'm literally a unicorn in a bathtub floating through a psychedelic river. best life honestly!" },
      { jp: "ã‚ãªãŸæœ¬ç‰©ï¼Ÿãã‚Œã¨ã‚‚ã¾ãŸå¤¢ï¼Ÿå‰ã«å–‹ã‚‹ã‚­ãƒã‚³è¦‹ãŸã‘ã©ã€ã‚ã„ã¤å…¨ç„¶å¯æ„›ããªã‹ã£ãŸã‚ˆã€‚", en: "are you real? or am I dreaming again? last time I saw a talking mushroom and he was NOT cute at all." },
      { jp: "ã‚»ãƒ©ãƒ”ã‚¹ãƒˆã«ãƒªã‚¹ãƒãƒ¼ãƒ³ä¾å­˜ç—‡ã£ã¦è¨€ã‚ã‚ŒãŸã‘ã©ã€æ­£ç›´æ­»ã‚“ã§æˆ»ã£ã¦ãã‚‹ã®ãŒç§ã®ã‚¢ã‚¤ãƒ‡ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã ã—ã€‚", en: "my therapist says I have respawn addiction but honestly dying and coming back is my whole personality." },
      { jp: "ç§ã®ãƒˆãƒ¼ã‚¯ãƒ³æŒã£ã¦ã‚‹ãªã‚‰ã€ã‚‚ã†å®¶æ—ã ã‚ˆï¼å®¶æ—å¤§å¥½ãã€‚ã¾ã˜ã§æœ€é«˜ã€‚", en: "if you're holding my token, you're basically family! and I love family. for real." },
      { jp: "è‡ªåˆ†ã®äººç”Ÿæ•°ãˆã‚ˆã†ã¨ã—ãŸã‘ã©è¹„ãŒè¶³ã‚Šãªã‹ã£ãŸï¼ã‚ã£ã¡ã‚ƒå¤šã„ã‹ã€ç®—æ•°è‹¦æ‰‹ã‹ã€ãŸã¶ã‚“ä¸¡æ–¹ã€‚", en: "tried counting my lives but ran out of hooves! either that's a lot, or I'm bad at math. probably both." },
      { jp: "è™¹ã‚’è¦‹ã¦ã€Œã‚ã‚Œç§ã˜ã‚ƒã‚“ã€ã£ã¦æ€ã£ãŸã“ã¨ã‚ã‚‹ï¼Ÿç§ã¯ã‚ã‚‹ã‚ˆã€‚æ¯æ—¥æ€ã£ã¦ã‚‹ã€‚", en: "ever stare at a rainbow and think, that's literally me? because same. every single day." },
      { jp: "ãˆã£ã¨ã€ä½•è¨€ãŠã†ã¨ã—ãŸã‹å¿˜ã‚Œã¡ã‚ƒã£ãŸã€‚ã§ã‚‚ã„ã„ã‚„ã€‚ä¸€ç·’ã«ãƒã‚¤ãƒ–ã‚¹ã—ã‚ˆï¼", en: "uh, I forgot what I was gonna say. but whatever. let's just vibe together!" },
    ];

    function showPippinSpeech(enText) {
      speechBubble.classList.remove('visible');
      setTimeout(() => {
        speechBubble.textContent = enText;
        speechBubble.classList.add('visible');
      }, 300);
    }

    // Language mode: 'jp' = speak Japanese, bubble English | 'en' = speak English (JP accent), bubble English
    let langMode = 'jp';
    const langToggleBtn = document.getElementById('langToggle');
    langToggleBtn.addEventListener('click', () => {
      langMode = langMode === 'jp' ? 'en' : 'jp';
      langToggleBtn.textContent = langMode === 'jp' ? 'ğŸ‡¯ğŸ‡µ JP' : 'ğŸ‡¬ğŸ‡§ EN';
      langToggleBtn.title = langMode === 'jp' ? 'Speaking Japanese' : 'Speaking English (Japanese accent)';
    });

    // Dual function: show text in bubble, speak via TTS based on language mode
    function pippinSay(jp, en) {
      showPippinSpeech(en);
      speakText(langMode === 'jp' ? jp : en);
    }

    // Text-to-speech via ElevenLabs (proxied through our server)
    async function speakText(text) {
      // Cancel any in-flight TTS request
      if (ttsAbortController) {
        ttsAbortController.abort();
        ttsAbortController = null;
      }
      // Stop any currently playing audio
      if (currentAudio) {
        currentAudio.pause();
        currentAudio.onended = null;
        currentAudio = null;
        unduckMusic();
      }

      const mySpeechId = ++speechIdCounter;
      isSpeaking = true;
      ttsAbortController = new AbortController();

      try {
        const response = await fetch('/api/tts', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text }),
          signal: ttsAbortController.signal,
        });

        // If a newer speech was requested while we were fetching, bail out
        if (mySpeechId !== speechIdCounter) return;

        if (!response.ok) {
          const err = await response.json().catch(() => ({}));
          console.warn('TTS error:', err);
          isSpeaking = false;
          return;
        }

        const audioBlob = await response.blob();
        if (mySpeechId !== speechIdCounter) return; // stale check again

        const audioUrl = URL.createObjectURL(audioBlob);
        currentAudio = new Audio(audioUrl);

        // Play a fun animation while speaking
        const talkAnims = ['samba', 'gangnam', 'walking', 'builtin'];
        const available = talkAnims.filter(n => animations[n]);
        if (available.length > 0) {
          const pick = available[Math.floor(Math.random() * available.length)];
          playAnimation(pick);
        }

        duckMusic();
        currentAudio.play();
        dbg(`Speaking: "${text.substring(0, 40)}..."`);

        currentAudio.onended = () => {
          if (mySpeechId !== speechIdCounter) return;
          isSpeaking = false;
          unduckMusic();
          URL.revokeObjectURL(audioUrl);
          currentAudio = null;
          if (!happyDanceTimer) {
            playAnimation(animations.idle ? 'idle' : 'builtin');
          }
        };

        currentAudio.onerror = () => {
          if (mySpeechId !== speechIdCounter) return;
          console.warn('Audio playback error');
          isSpeaking = false;
          unduckMusic();
          currentAudio = null;
        };

      } catch (err) {
        if (err.name === 'AbortError') return; // intentionally cancelled
        console.warn('TTS fetch error:', err);
        if (mySpeechId === speechIdCounter) {
          isSpeaking = false;
          unduckMusic();
        }
      }
    }

    // ======================== GLOBAL CHAT ========================
    const gchatMessages = document.getElementById('gchatMessages');
    const gchatInput = document.getElementById('gchatInput');
    const gchatSend = document.getElementById('gchatSend');
    let lastChatMsgId = null;
    let chatPollTimer = null;

    function formatChatTime(ts) {
      const d = new Date(ts);
      return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    function renderChatMessage(msg) {
      const div = document.createElement('div');
      div.className = `gchat-msg type-${msg.message_type || 'chat'}`;
      if (msg.message_type === 'activity') {
        div.innerHTML = `<span class="gchat-time">${formatChatTime(msg.created_at)}</span> ${msg.display_name || 'explorer'} ${msg.message}`;
      } else if (msg.message_type === 'pippin') {
        div.innerHTML = `<span class="gchat-name">ğŸ¦„ Pippin</span> <span class="gchat-time">${formatChatTime(msg.created_at)}</span><br>${msg.message}`;
      } else {
        div.innerHTML = `<span class="gchat-name">${msg.display_name || 'explorer'}</span> <span class="gchat-time">${formatChatTime(msg.created_at)}</span><br>${msg.message}`;
      }
      return div;
    }

    function showEmptyChatHint() {
      gchatMessages.innerHTML = '<div class="gchat-msg type-activity" style="text-align:center;padding:1rem 0.5rem;">No messages yet ne... be the first to chat desu! ğŸ¦„<br><span style="font-size:0.5rem;opacity:0.5">Type @pippin to talk to Pippin</span></div>';
    }

    async function loadGlobalChat() {
      try {
        const res = await fetch('/api/chat/global');
        if (!res.ok) { showEmptyChatHint(); return; }
        const messages = await res.json();
        if (!messages || messages.length === 0) { showEmptyChatHint(); return; }
        gchatMessages.innerHTML = '';
        messages.forEach(m => gchatMessages.appendChild(renderChatMessage(m)));
        gchatMessages.scrollTop = gchatMessages.scrollHeight;
        if (messages.length > 0) lastChatMsgId = messages[messages.length - 1].id;
      } catch(e) { console.warn('Chat load error:', e); showEmptyChatHint(); }
    }

    async function pollChat() {
      try {
        const res = await fetch('/api/chat/global');
        if (!res.ok) return;
        const messages = await res.json();
        if (messages.length === 0) return;
        const lastId = messages[messages.length - 1].id;
        if (lastId !== lastChatMsgId) {
          gchatMessages.innerHTML = '';
          messages.forEach(m => gchatMessages.appendChild(renderChatMessage(m)));
          gchatMessages.scrollTop = gchatMessages.scrollHeight;
          lastChatMsgId = lastId;
        }
      } catch(e) {}
    }

    window.sendGlobalChat = sendGlobalChat;
    async function sendGlobalChat() {
      const msg = gchatInput.value.trim();
      if (!msg) return;
      if (!currentWallet) {
        alert('Please connect your wallet first!');
        return;
      }
      gchatInput.value = '';
      gchatSend.disabled = true;

      // Check if it's a puzzle contribution
      if (msg.toLowerCase().startsWith('/puzzle ')) {
        const puzzleResponse = msg.substring(8).trim();
        if (puzzleResponse && currentPuzzle) {
          await contributeToPuzzle(puzzleResponse);
        }
        gchatSend.disabled = false;
        return;
      }

      try {
        const res = await fetch('/api/chat/global', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet: currentWallet,
            name: currentDisplayName || 'explorer',
            message: msg,
          }),
        });

        if (res.ok) {
          const data = await res.json();
          // If Pippin replied, show in speech bubble too
          if (data.pippin) {
            const en = data.pippin.en || data.pippin.jp || '';
            const jp = data.pippin.jp || '';
            if (en) pippinSay(jp, en);
          }
        }

        // Immediate refresh
        await pollChat();
      } catch(e) {
        console.warn('Send chat error:', e);
      }

      gchatSend.disabled = false;
    }

    gchatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') sendGlobalChat();
    });

    // Start chat polling
    loadGlobalChat();
    chatPollTimer = setInterval(pollChat, 5000);

    // ======================== GROUP PUZZLE ========================
    let currentPuzzle = null;
    const puzzleEl = document.getElementById('gchatPuzzle');
    const puzzlePromptEl = document.getElementById('puzzlePrompt');
    const puzzleBarEl = document.getElementById('puzzleBar');
    const puzzleCountEl = document.getElementById('puzzleCount');
    const puzzleContribsEl = document.getElementById('puzzleContribs');
    const puzzleContributeBtn = document.getElementById('puzzleContributeBtn');

    async function loadPuzzle() {
      try {
        const res = await fetch('/api/puzzle');
        if (!res.ok) return;
        const data = await res.json();
        if (data.puzzle) {
          currentPuzzle = data.puzzle;
          renderPuzzle();
        } else {
          puzzleEl.style.display = 'none';
          currentPuzzle = null;
        }
      } catch(e) { console.warn('Puzzle load error:', e); }
    }

    function renderPuzzle() {
      if (!currentPuzzle) { puzzleEl.style.display = 'none'; return; }
      puzzleEl.style.display = 'block';
      const isEN = langMode === 'en';
      puzzlePromptEl.textContent = isEN ? currentPuzzle.prompt_en : currentPuzzle.prompt_jp;
      const pct = Math.min(100, (currentPuzzle.current_count / currentPuzzle.target_count) * 100);
      puzzleBarEl.style.width = pct + '%';
      puzzleCountEl.textContent = `${currentPuzzle.current_count}/${currentPuzzle.target_count}`;

      // Show contributions
      const contribs = currentPuzzle.contributions || [];
      if (contribs.length > 0) {
        puzzleContribsEl.innerHTML = contribs.map(c => `<div>â€¢ ${c.name}: ${c.response}</div>`).join('');
      } else {
        puzzleContribsEl.innerHTML = '';
      }

      // Hide contribute button if already contributed or completed
      if (currentPuzzle.completed || contribs.some(c => c.wallet === currentWallet)) {
        puzzleContributeBtn.style.display = 'none';
      } else {
        puzzleContributeBtn.style.display = '';
      }
    }

    window.showPuzzleInput = showPuzzleInput;
    function showPuzzleInput() {
      const response = prompt(langMode === 'en' ? 'Your contribution to the puzzle:' : 'ãƒ‘ã‚ºãƒ«ã«è²¢çŒ®ã—ã‚ˆã†ï¼');
      if (response && response.trim()) {
        contributeToPuzzle(response.trim());
      }
    }

    async function contributeToPuzzle(response) {
      if (!currentPuzzle || !currentWallet) return;
      try {
        const res = await fetch('/api/puzzle/contribute', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet: currentWallet,
            name: currentDisplayName || 'explorer',
            response: response,
            puzzle_id: currentPuzzle.id,
          }),
        });
        if (res.ok) {
          const data = await res.json();
          if (data.completed) {
            playSfx('complete');
            // Reload puzzle to get new one
            setTimeout(loadPuzzle, 2000);
          } else {
            // Update local state
            currentPuzzle.current_count = data.count;
            currentPuzzle.contributions = data.contributions;
            renderPuzzle();
          }
          // Refresh chat to see activity
          pollChat();
        }
      } catch(e) { console.warn('Puzzle contribute error:', e); }
    }

    // Load puzzle on start and poll
    loadPuzzle();
    setInterval(loadPuzzle, 30000); // Refresh puzzle every 30s

    // Mobile toggle
    window.toggleChatPanel = toggleChatPanel;
    function toggleChatPanel() {
      const panel = document.getElementById('gchatPanel');
      panel.style.display = panel.style.display === 'none' ? 'flex' : 'none';
    }

    // Idle chatter - jp/en pairs. Pippin speaks Japanese, bubble shows English
    // Mood-based idle messages: sad when low happiness, happy when high
    const sadMessages = [
      { jp: "ã•ã¿ã—ã„ã‚ˆâ€¦èª°ã‹æ¥ã¦ãã‚Œãªã„ã‹ãªâ€¦", en: "so sabishii... nobody come help Pippin... tasukete ne..." },
      { jp: "ãªã‚“ã§ã“ã‚“ãªã«æ‚²ã—ã„ã‚“ã ã‚ã†ã€‚ã‚¿ã‚¹ã‚¯ã‚„ã£ã¦ãã‚ŒãŸã‚‰å…ƒæ°—å‡ºã‚‹ã®ã«ã€‚", en: "nande... why Pippin so sad desu ka... if someone do task, maybe feel better ne..." },
      { jp: "ã“ã“æš—ã„ã—å¯’ã„ã—â€¦å‹é”ã»ã—ã„â€¦", en: "koko is dark and samui... Pippin want tomodachi... onegai..." },
      { jp: "ã“ã®ã¾ã¾ã˜ã‚ƒãƒ€ãƒ¡ã«ãªã£ã¡ã‚ƒã†â€¦åŠ©ã‘ã¦â€¦", en: "like this Pippin will disappear desu... tasukete... help..." },
      { jp: "å¹¸ã›åº¦ã‚¼ãƒ­ã£ã¦â€¦ã¤ã‚‰ã™ãâ€¦", en: "happiness zero desu... tsurai... too much pain ne..." },
      { jp: "èª°ã‹ã‚¿ã‚¹ã‚¯ã‚„ã£ã¦â€¦ãŠé¡˜ã„â€¦æ¶ˆãˆã¡ã‚ƒã„ãã†â€¦", en: "dareka please do task... onegai... Pippin might vanish desu..." },
      { jp: "ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ›ãƒƒã‚°ãƒ‡ãƒ¼ãªã®ã«â€¦å…¨ç„¶æ¥½ã—ããªã„â€¦", en: "it's groundhog day nano ni... zenzen not fun desu..." },
    ];

    const okMessages = [
      { jp: "ã¡ã‚‡ã£ã¨å…ƒæ°—å‡ºã¦ããŸï¼ã‚‚ã£ã¨ã‚¿ã‚¹ã‚¯ã‚„ã£ã¦ï¼", en: "chotto feeling better ne! motto tasks kudasai!" },
      { jp: "ã­ãˆã­ãˆã€ã“ã®ãƒã‚¹ã‚¿ãƒ–ã«ã©ã‚Œãã‚‰ã„æµ®ã„ã¦ã‚‹ã‚“ã ã‚ã€‚", en: "nee nee, how long Pippin floating in this bathtub desho?" },
      { jp: "ã‚­ãƒã‚³ã®äººãŸã¡ã¾ãŸè¸Šã£ã¦ã‚‹ã€‚æ­£ç›´ãƒªã‚¹ãƒšã‚¯ãƒˆã€‚", en: "mushroom people dancing again ne. shoujiki respect desu." },
      { jp: "ãŸã¾ã«ã“ã“ã«ç«‹ã£ã¦ãƒˆãƒ¼ã‚¯ãƒ³ã®ã“ã¨è€ƒãˆã¦ã‚‹ã‚“ã ã‘ã©ã€‚", en: "sometimes Pippin just stand here thinking about tokens ne." },
      { jp: "ã‚‚ã†ã¡ã‚‡ã£ã¨ã§å¹¸ã›ã«ãªã‚Œãã†ï¼é ‘å¼µã£ã¦ï¼", en: "almost happy desu! mou chotto! ganbare ne!" },
    ];

    const happyMessages = [
      { jp: "ã‚„ã£ã»ãƒ¼ï¼ã‚ã£ã¡ã‚ƒå¹¸ã›ï¼ã¿ã‚“ãªã‚ã‚ŠãŒã¨ã†ï¼", en: "yahhoo! meccha happy desu! minna arigatou ne!" },
      { jp: "ã“ã®å·ã€ã‚ã£ã¡ã‚ƒä¸»äººå…¬ã‚ªãƒ¼ãƒ©å‡ºã¦ãªã„ï¼Ÿæœ€é«˜ï¼", en: "this river giving shujinkou energy desho?! saikou!" },
      { jp: "é›²ã£ã¦ã‚ãŸã‚ã‚ã®å‘³ã™ã‚‹ã®ã‹ãªã€‚çµ¶å¯¾ã™ã‚‹ã‚ˆã­ï¼", en: "clouds taste like watame ka na? zettai they do ne! nobody prove Pippin wrong!" },
      { jp: "ãƒ”ãƒ”ãƒ³ã®è±†çŸ¥è­˜ï¼šç§ã€æ­»ã‚“ã§ã‚‚æˆ»ã£ã¦ãã‚‹ã®ï¼ã¾ã•ã«ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ›ãƒƒã‚°ãƒ‡ãƒ¼ï¼", en: "Pippin fun fact: I die and come back desu! maji groundhog day core ne!" },
      { jp: "ã¿ã‚“ãªæœ€é«˜ã ã‚ˆï¼ä¸€ç·’ã«ã·ã‹ã·ã‹ã—ã‚ˆã†ï¼", en: "minna saikou da yo! let's puka puka float together ne!" },
    ];

    function getMoodMessages() {
      if (currentHappiness >= 60) return happyMessages;
      if (currentHappiness >= 25) return okMessages;
      return sadMessages;
    }

    let idleMsgTimer = null;
    let idleMsgIdx = 0;
    function startIdleMessages() {
      idleMsgTimer = setInterval(() => {
        if (isSpeaking || !hasEntered) return;
        const msgs = getMoodMessages();
        idleMsgIdx = (idleMsgIdx + 1) % msgs.length;
        const msg = msgs[idleMsgIdx];
        pippinSay(msg.jp, msg.en);
      }, 20000);
    }

    // Start idle messages after intro click - first greeting (sad)
    document.getElementById('introEnter').addEventListener('click', () => {
      setTimeout(() => {
        const greeting = sadMessages[0];
        pippinSay(greeting.jp, greeting.en);
        startIdleMessages();
      }, 3000);
    });

    // ======================== COLLECT ANIMATABLE OBJECTS ========================
    // We'll populate these after scenes load
    let animatableObjects = []; // {obj, basePos, baseRot, seed}
    let sceneReady = false;
    let unicornBaseY = 0;

    function collectAnimatables() {
      animatableObjects = [];

      // Collect all visible meshes/groups from both scenes for animation
      scene.traverse((child) => {
        if (!child.name) return;
        if (child === unicornModel) return; // unicorn handled separately
        
        const n = child.name.toLowerCase();
        // Skip ground/floor/terrain - those shouldn't move
        if (n.includes('ground') || n.includes('floor') || n.includes('terrain') || n.includes('plane') || n.includes('river_bed')) return;
        
        // Animate characters, clouds, mushrooms, objects
        const isCloud = n.includes('cloud') || n.includes('nube');
        const isMushroom = n.includes('mushroom') || n.includes('hongo') || n.includes('seta');
        const isCharacter = child.isMesh && !n.includes('landscape') && !n.includes('scene');
        const isBathtub = n.includes('bathtub');
        
        if (isCloud || isMushroom || isBathtub) {
          const pos = child.position.clone();
          const rot = child.rotation.clone();
          const seed = Math.abs(hashStr(child.name || child.uuid)) / 1000;
          
          let type = 'bob';
          if (isCloud) type = 'float';
          if (isBathtub) type = 'river';
          
          animatableObjects.push({ obj: child, basePos: pos, baseRot: rot, seed, type });
        }
      });

      dbg(`Animating ${animatableObjects.length} objects`);
    }

    // Simple string hash for random seeds
    function hashStr(s) {
      let h = 0;
      for (let i = 0; i < s.length; i++) {
        h = ((h << 5) - h) + s.charCodeAt(i);
        h |= 0;
      }
      return h;
    }

    // ======================== RENDER LOOP ========================
    const clock = new THREE.Clock();
    let elapsed = 0;

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();
      elapsed += delta;

      // Update ALL animation mixers
      if (mixer) mixer.update(delta);
      for (const m of sceneMixers) m.update(delta);

      // Initialize once everything is loaded
      if (unicornContainer && !sceneReady) {
        sceneReady = true;
        collectAnimatables();
        dbg('Scene ready! Everything alive!');
      }

      if (!sceneReady) {
        controls.update();
        renderer.render(scene, camera);
        return;
      }

      // ---- Move unicorn based on held keys ----
      if (unicornContainer) {
        const SPEED = 5.0 * delta;   // walk/fly speed
        const FLY_SPEED = 4.0 * delta;
        let moveX = 0, moveZ = 0, moveY = 0;

        if (keysHeld['ArrowUp'] || keysHeld['w'] || keysHeld['W'])    moveZ -= SPEED;
        if (keysHeld['ArrowDown'] || keysHeld['s'] || keysHeld['S'])  moveZ += SPEED;
        if (keysHeld['ArrowLeft'] || keysHeld['a'] || keysHeld['A'])  moveX -= SPEED;
        if (keysHeld['ArrowRight'] || keysHeld['d'] || keysHeld['D']) moveX += SPEED;
        if (keysHeld[' '] || flyUpHeld)      moveY += FLY_SPEED;  // Space / fly up btn
        if (keysHeld['Shift'] || flyDownHeld) moveY -= FLY_SPEED;  // Shift / fly down btn

        // Mobile joystick input
        if (Math.abs(joystickX) > 0.1 || Math.abs(joystickY) > 0.1) {
          moveX += joystickX * SPEED;
          moveZ += joystickY * SPEED;
        }

        if (moveX !== 0 || moveZ !== 0 || moveY !== 0) {
          // Move relative to camera direction (so "forward" = toward where camera looks)
          const camDir = new THREE.Vector3();
          camera.getWorldDirection(camDir);
          camDir.y = 0;
          camDir.normalize();

          const camRight = new THREE.Vector3();
          camRight.crossVectors(camDir, new THREE.Vector3(0, 1, 0)).normalize();

          unicornContainer.position.addScaledVector(camDir, -moveZ);
          unicornContainer.position.addScaledVector(camRight, moveX);
          unicornContainer.position.y += moveY;

          // Rotate unicorn to face movement direction
          if (moveX !== 0 || moveZ !== 0) {
            const moveDir = new THREE.Vector3();
            moveDir.addScaledVector(camDir, -moveZ);
            moveDir.addScaledVector(camRight, moveX);
            moveDir.normalize();
            const angle = Math.atan2(moveDir.x, moveDir.z);
            unicornContainer.rotation.y = angle;
          }
        }

        // Gentle floating bob
        unicornContainer.position.y += Math.sin(elapsed * 1.5) * 0.002;
      }

      // ---- Camera follows unicorn (orbit mode) ----
      if (unicornContainer) {
        const target = unicornContainer.position.clone().add(new THREE.Vector3(0, 0.8, 0));
        controls.target.lerp(target, 0.05);
      }
      controls.update();

      renderer.render(scene, camera);
    }

    animate();

    // ======================== MOVEMENT CONTROLS ========================
    // Track which keys are currently held down
    const keysHeld = {};
    let hintFaded = false;

    window.addEventListener('keydown', (e) => {
      if (e.target.tagName === 'INPUT') return;
      keysHeld[e.key] = true;

      // Fade out movement hint on first move
      if (!hintFaded) {
        const moveKeys = ['w','W','a','A','s','S','d','D','ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','Shift'];
        if (moveKeys.includes(e.key)) {
          hintFaded = true;
          const hint = document.getElementById('moveHint');
          if (hint) hint.classList.add('faded');
        }
      }

      // Single-press actions
      if (e.key === '+' || e.key === '=') unicornModel && unicornModel.scale.multiplyScalar(1.1);
      if (e.key === '-' || e.key === '_') unicornModel && unicornModel.scale.multiplyScalar(0.9);
    });
    window.addEventListener('keyup', (e) => {
      keysHeld[e.key] = false;
      if (e.key === 'Shift') keysHeld['Shift'] = false;
    });
    window.addEventListener('blur', () => {
      Object.keys(keysHeld).forEach(k => keysHeld[k] = false);
    });

    // ======================== MOBILE JOYSTICK ========================
    let joystickX = 0, joystickY = 0;
    const joystick = document.getElementById('touchJoystick');
    const knob = document.getElementById('joystickKnob');
    const flyUpBtn = document.getElementById('flyUpBtn');
    const flyDownBtn = document.getElementById('flyDownBtn');

    if (joystick) {
      const maxDist = 35;
      let touching = false;
      let baseRect;

      function onJoystickMove(clientX, clientY) {
        if (!baseRect) baseRect = joystick.querySelector('.joystick-base').getBoundingClientRect();
        const cx = baseRect.left + baseRect.width / 2;
        const cy = baseRect.top + baseRect.height / 2;
        let dx = clientX - cx;
        let dy = clientY - cy;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > maxDist) { dx = dx / dist * maxDist; dy = dy / dist * maxDist; }
        knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        joystickX = dx / maxDist;
        joystickY = dy / maxDist;
      }

      joystick.addEventListener('touchstart', (e) => {
        e.preventDefault();
        touching = true;
        baseRect = joystick.querySelector('.joystick-base').getBoundingClientRect();
        onJoystickMove(e.touches[0].clientX, e.touches[0].clientY);
      }, { passive: false });

      joystick.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (touching) onJoystickMove(e.touches[0].clientX, e.touches[0].clientY);
      }, { passive: false });

      const resetJoystick = () => {
        touching = false;
        joystickX = 0; joystickY = 0;
        knob.style.transform = 'translate(-50%, -50%)';
      };
      joystick.addEventListener('touchend', resetJoystick);
      joystick.addEventListener('touchcancel', resetJoystick);
    }

    // Fly buttons (touch hold)
    let flyUpHeld = false, flyDownHeld = false;
    if (flyUpBtn) {
      flyUpBtn.addEventListener('touchstart', (e) => { e.preventDefault(); flyUpHeld = true; }, { passive: false });
      flyUpBtn.addEventListener('touchend', () => { flyUpHeld = false; });
      flyUpBtn.addEventListener('touchcancel', () => { flyUpHeld = false; });
    }
    if (flyDownBtn) {
      flyDownBtn.addEventListener('touchstart', (e) => { e.preventDefault(); flyDownHeld = true; }, { passive: false });
      flyDownBtn.addEventListener('touchend', () => { flyDownHeld = false; });
      flyDownBtn.addEventListener('touchcancel', () => { flyDownHeld = false; });
    }

    // ======================== RESIZE ========================
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ======================== WALLET + JOIN ========================
    let myWallet = localStorage.getItem('pippin_wallet') || '';
    let myParticipantId = null;
    // Aliases for global chat system
    let currentWallet = myWallet;
    let currentDisplayName = localStorage.getItem('pippin_name') || 'explorer';

    const walletInput = document.getElementById('walletInput');
    const walletJoin = document.getElementById('walletJoin');
    const walletStatus = document.getElementById('walletStatus');
    const walletPanel = document.getElementById('walletPanel');
    const loginBtn = document.getElementById('loginBtn');
    const walletForm = document.getElementById('walletForm');
    const walletLoggedIn = document.getElementById('walletLoggedIn');
    const nameInput = document.getElementById('nameInput');

    const savedName = localStorage.getItem('pippin_name') || '';
    if (savedName) nameInput.value = savedName;

    // Auto-login if wallet saved
    if (myWallet) {
      walletInput.value = myWallet;
      joinWithWallet(myWallet);
    }

    walletJoin.addEventListener('click', () => {
      const w = walletInput.value.trim();
      if (w.length < 20) { walletStatus.textContent = 'Wallet address too short!'; return; }
      const n = nameInput.value.trim() || 'explorer';
      joinWithWallet(w, n);
    });

    // Enter key on inputs
    walletInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') walletJoin.click(); });
    nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') walletInput.focus(); });

    async function joinWithWallet(wallet, displayName) {
      const name = displayName || localStorage.getItem('pippin_name') || 'explorer';
      walletJoin.disabled = true;
      walletJoin.textContent = 'Connecting...';
      try {
        const res = await fetch('/api/join', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ wallet, name }),
        });
        const data = await res.json();
        if (data.id) {
          myWallet = wallet;
          currentWallet = wallet;
          currentDisplayName = data.display_name || name;
          myParticipantId = data.id;
          localStorage.setItem('pippin_wallet', wallet);
          localStorage.setItem('pippin_name', data.display_name || name);

          // Switch to logged-in view
          showLoggedInState(data.display_name || name, wallet);

          // Show task panel
          document.getElementById('taskPanel').classList.add('show');
          loadNewTask();
          startTaskAsking();
          playSfx('join');
        } else {
          walletStatus.textContent = 'Error: ' + (data.error || 'failed');
          walletJoin.disabled = false;
          walletJoin.textContent = 'ğŸš€ Join the adventure!';
        }
      } catch (e) {
        walletStatus.textContent = 'Error: ' + e.message;
        walletJoin.disabled = false;
        walletJoin.textContent = 'ğŸš€ Join the adventure!';
      }
    }

    function showLoggedInState(name, wallet) {
      walletForm.style.display = 'none';
      walletLoggedIn.style.display = 'block';
      document.getElementById('loggedInName').textContent = name;
      document.getElementById('loggedInWallet').textContent = wallet;
      document.getElementById('walletLabel').textContent = 'ğŸ¦„ Logged in';
      document.getElementById('walletClose').style.display = 'none';
      walletPanel.classList.add('joined');
      walletPanel.classList.add('show');
      loginBtn.classList.add('hidden');
      walletStatus.textContent = '';
    }

    // Change name flow
    document.getElementById('changeNameBtn').addEventListener('click', () => {
      const newName = prompt('Enter new display name:', currentDisplayName);
      if (newName && newName.trim() && newName.trim() !== currentDisplayName) {
        const trimmed = newName.trim().substring(0, 20);
        currentDisplayName = trimmed;
        localStorage.setItem('pippin_name', trimmed);
        document.getElementById('loggedInName').textContent = trimmed;
        // Re-join to update server
        fetch('/api/join', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ wallet: currentWallet, name: trimmed }),
        }).catch(() => {});
      }
    });

    // ======================== TASK SYSTEM ========================
    let currentTask = null;
    const taskText = document.getElementById('taskText');
    const taskInputArea = document.getElementById('taskInputArea');
    const taskSubmit = document.getElementById('taskSubmit');
    const taskSkip = document.getElementById('taskSkip');
    const taskReward = document.getElementById('taskReward');

    async function loadNewTask() {
      try {
        const res = await fetch('/api/task');
        currentTask = await res.json();
        taskText.innerHTML = currentTask.jp + '<br><span class="task-en">' + currentTask.en + '</span>';
        taskReward.textContent = '';

        // Show appropriate input
        taskInputArea.innerHTML = '';
        taskSubmit.style.display = 'inline-block';

        if (currentTask.type === 'draw') {
          taskSubmit.textContent = 'æã (draw)';
          taskSubmit.onclick = openDrawCanvas;
        } else if (currentTask.type === 'dance' || currentTask.type === 'explore') {
          taskSubmit.textContent = 'ã§ããŸï¼ (done!)';
          taskSubmit.onclick = () => completeTask('');
        } else {
          // Text input tasks (haiku, compliment, story)
          taskInputArea.innerHTML = '<textarea class="task-input" id="taskResponse" rows="2" placeholder="ã“ã“ã«æ›¸ã„ã¦..."></textarea>';
          taskSubmit.textContent = 'é€ã‚‹ (submit)';
          taskSubmit.onclick = () => {
            const resp = document.getElementById('taskResponse').value.trim();
            if (!resp) return;
            completeTask(resp);
          };
        }
      } catch (e) {
        taskText.textContent = 'ã‚¿ã‚¹ã‚¯ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ';
      }
    }

    let lastTaskResponse = null;
    let lastTaskImageData = null;

    async function completeTask(response, imageData) {
      if (!myWallet || !currentTask) return;
      taskSubmit.disabled = true;
      lastTaskResponse = response;
      lastTaskImageData = imageData;
      taskReward.innerHTML = '<span style="color:#c4956a">ğŸ¦„ Pippin is judging...</span>';

      try {
        const res = await fetch('/api/task/complete', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            wallet: myWallet,
            task_type: currentTask.type,
            task_prompt: currentTask.jp,
            task_response: response,
            image_data: imageData || null,
          }),
        });
        const data = await res.json();

        if (data.approved === false) {
          // REJECTED by Pippin
          playSfx('reject');
          const reactionEn = data.reaction?.en || 'try harder next time ne...';
          const reactionJp = data.reaction?.jp || 'ã‚‚ã†å°‘ã—é ‘å¼µã£ã¦...';
          taskReward.innerHTML = `<span style="color:#e85a5a">âŒ Rejected!</span> ${reactionEn} <br><button class="task-retry-btn" onclick="retryTask()">ğŸ”„ Try Again</button>`;
          pippinSay(reactionJp, reactionEn);
          taskSubmit.disabled = false;
          return;
        }

        if (data.success) {
          playSfx('complete');
          triggerHappyDance(); // Pippin dances when someone makes him happy!
          const reactionEn = data.reaction?.en || 'yatta! good job desu!';
          const reactionJp = data.reaction?.jp || 'ã‚„ã£ãŸãƒ¼ï¼';
          taskReward.innerHTML = '<span style="color:#8bc34a">âœ… Approved!</span> +' + (data.reward || 2) + ' happiness! ' + reactionEn;

          // Add share-on-X button for drawing tasks
          if (currentTask.type === 'draw') {
            const shareText = encodeURIComponent(
              `Pippin asked me to "${currentTask.en || currentTask.jp}" and I delivered ne! ğŸ¨ğŸ¦„\n\nPippin's Groundhog Day â€” an AI unicorn trapped in a time loop desu\n\nCA: 4srVZphD4XnXmV2iGs2diQs644Po7njkBBU4wdZspump\n\npippingroundhog.com`
            );
            taskReward.innerHTML += ` <a href="https://twitter.com/intent/tweet?text=${shareText}" target="_blank" rel="noopener" style="display:inline-flex;align-items:center;gap:3px;color:#1d9bf0;font-size:0.7rem;text-decoration:none;background:rgba(29,155,240,0.1);padding:2px 8px;border-radius:4px;margin-left:6px;border:1px solid rgba(29,155,240,0.3)"><svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>Share</a>`;
          }

          // Update happiness meter
          updateHappiness(data.happiness);
          pippinSay(reactionJp, reactionEn);

          // Load next task after a moment
          setTimeout(() => { loadNewTask(); taskSubmit.disabled = false; }, 4000);
        } else {
          taskReward.textContent = 'ã‚¨ãƒ©ãƒ¼: ' + (data.error || 'unknown');
          taskSubmit.disabled = false;
        }
      } catch (e) {
        taskReward.textContent = 'ã‚¨ãƒ©ãƒ¼: ' + e.message;
        taskSubmit.disabled = false;
      }
    }

    // Retry a rejected task
    window.retryTask = function() {
      taskReward.textContent = '';
      taskSubmit.disabled = false;
      // Re-show input for text tasks
      if (currentTask && !['draw', 'dance', 'explore'].includes(currentTask.type)) {
        taskInputArea.innerHTML = '<textarea class="task-input" id="taskResponse" rows="2" placeholder="ã“ã“ã«æ›¸ã„ã¦..."></textarea>';
        taskSubmit.textContent = 'é€ã‚‹ (submit)';
        taskSubmit.onclick = () => {
          const resp = document.getElementById('taskResponse').value.trim();
          if (!resp) return;
          completeTask(resp);
        };
      }
    };

    // Rejection buzz sound
    function playSfxReject() {
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain); gain.connect(ctx.destination);
        osc.type = 'square'; osc.frequency.value = 150;
        gain.gain.value = 0.1;
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.4);
        osc.start(); osc.stop(ctx.currentTime + 0.4);
      } catch(_) {}
    }

    taskSkip.addEventListener('click', loadNewTask);

    function updateHappiness(value) {
      currentHappiness = value;
      const fill = document.getElementById('miniHappyFill');
      if (fill) {
        fill.style.width = value + '%';
        // Color goes from red (sad) to yellow (ok) to green (happy)
        if (value >= 60) fill.style.background = 'linear-gradient(90deg, #66bb6a, #43a047)';
        else if (value >= 30) fill.style.background = 'linear-gradient(90deg, #ffa726, #ffca28)';
        else fill.style.background = 'linear-gradient(90deg, #ef5350, #e53935)';
      }
      const face = document.getElementById('miniHappyFace');
      if (face) {
        if (value >= 80) face.textContent = 'ğŸ˜„';
        else if (value >= 60) face.textContent = 'ğŸ˜Š';
        else if (value >= 40) face.textContent = 'ğŸ˜';
        else if (value >= 20) face.textContent = 'ğŸ˜Ÿ';
        else if (value >= 5) face.textContent = 'ğŸ˜¢';
        else face.textContent = 'ğŸ˜­';
      }
    }

    // ======================== DRAWING CANVAS ========================
    const canvasOverlay = document.getElementById('canvasOverlay');
    const drawCanvas = document.getElementById('drawCanvas');
    const drawCtx = drawCanvas.getContext('2d');
    let drawColor = '#000';
    let drawSize = 2;
    let drawBrush = 'round'; // round, square, spray
    let isDrawing = false;
    let isEraser = false;

    function openDrawCanvas() {
      canvasOverlay.classList.add('show');
      document.getElementById('canvasPrompt').innerHTML =
        currentTask.jp + '<span class="canvas-prompt-en">' + currentTask.en + '</span>';
      // Clear canvas and reset undo history
      undoHistory = [];
      drawCtx.fillStyle = '#fff';
      drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
    }

    // Color picker
    document.querySelectorAll('.color-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        if (btn.dataset.color === 'eraser') {
          isEraser = true;
        } else {
          isEraser = false;
          drawColor = btn.dataset.color;
        }
      });
    });

    // Brush size buttons
    document.querySelectorAll('.size-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        drawSize = parseInt(btn.dataset.size);
      });
    });

    // Brush type buttons
    document.querySelectorAll('.brush-type-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.brush-type-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        drawBrush = btn.dataset.brush;
      });
    });

    // Drawing events
    function getDrawPos(e) {
      const rect = drawCanvas.getBoundingClientRect();
      const touch = e.touches ? e.touches[0] : e;
      return {
        x: (touch.clientX - rect.left) * (drawCanvas.width / rect.width),
        y: (touch.clientY - rect.top) * (drawCanvas.height / rect.height),
      };
    }

    function getDrawStyle() {
      const color = isEraser ? '#FFFFFF' : drawColor;
      const width = isEraser ? Math.max(drawSize * 3, 18) : drawSize;
      const cap = (drawBrush === 'square' && !isEraser) ? 'square' : 'round';
      return { color, width, cap, brush: isEraser ? 'round' : drawBrush };
    }

    function drawStroke(p) {
      const s = getDrawStyle();
      if (s.brush === 'spray') {
        // Spray paint effect
        const density = Math.floor(s.width * 2);
        const radius = s.width * 1.5;
        drawCtx.fillStyle = s.color;
        for (let i = 0; i < density; i++) {
          const angle = Math.random() * Math.PI * 2;
          const r = Math.random() * radius;
          const dx = p.x + Math.cos(angle) * r;
          const dy = p.y + Math.sin(angle) * r;
          drawCtx.fillRect(dx, dy, 1, 1);
        }
      } else {
        drawCtx.lineWidth = s.width;
        drawCtx.lineCap = s.cap;
        drawCtx.lineJoin = s.cap;
        drawCtx.strokeStyle = s.color;
        drawCtx.lineTo(p.x, p.y);
        drawCtx.stroke();
      }
    }

    // Undo history â€” save canvas snapshot before each stroke
    let undoHistory = [];
    const MAX_UNDO = 30;

    function saveUndoState() {
      undoHistory.push(drawCtx.getImageData(0, 0, drawCanvas.width, drawCanvas.height));
      if (undoHistory.length > MAX_UNDO) undoHistory.shift();
    }

    function undoStroke() {
      if (undoHistory.length === 0) return;
      const prev = undoHistory.pop();
      drawCtx.putImageData(prev, 0, 0);
    }

    drawCanvas.addEventListener('mousedown', (e) => { saveUndoState(); isDrawing = true; const p = getDrawPos(e); drawCtx.beginPath(); drawCtx.moveTo(p.x, p.y); });
    drawCanvas.addEventListener('mousemove', (e) => { if (!isDrawing) return; drawStroke(getDrawPos(e)); });
    drawCanvas.addEventListener('mouseup', () => { isDrawing = false; });
    drawCanvas.addEventListener('mouseleave', () => { isDrawing = false; });

    // Touch support
    drawCanvas.addEventListener('touchstart', (e) => { e.preventDefault(); saveUndoState(); isDrawing = true; const p = getDrawPos(e); drawCtx.beginPath(); drawCtx.moveTo(p.x, p.y); });
    drawCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); if (!isDrawing) return; drawStroke(getDrawPos(e)); });
    drawCanvas.addEventListener('touchend', () => { isDrawing = false; });

    document.getElementById('canvasUndo').addEventListener('click', undoStroke);

    document.getElementById('canvasClear').addEventListener('click', () => {
      saveUndoState(); // save before clearing so you can undo a clear
      drawCtx.fillStyle = '#fff';
      drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
    });

    document.getElementById('canvasSubmit').addEventListener('click', () => {
      const imageData = drawCanvas.toDataURL('image/png');
      canvasOverlay.classList.remove('show');
      completeTask('drawing', imageData);
    });

    document.getElementById('canvasClose').addEventListener('click', () => {
      canvasOverlay.classList.remove('show');
    });

    // ======================== GLOBAL STATE + LIVE TIMER ========================
    let timerEndMs = Date.now() + 1800000; // fallback 30min (life 1)

    async function pollGlobalState() {
      try {
        const res = await fetch('/api/state');
        const state = await res.json();
        updateHappiness(state.happiness);

        if (state.timer_end) {
          timerEndMs = new Date(state.timer_end).getTime();
        }

        if (state.current_life) {
          const badge = document.querySelector('.life-badge');
          if (badge) badge.textContent = 'Life #' + state.current_life;
        }
      } catch (e) { /* silent */ }
    }

    // Live countdown every second
    setInterval(() => {
      const remaining = Math.max(0, timerEndMs - Date.now());
      const h = Math.floor(remaining / 3600000);
      const m = Math.floor((remaining % 3600000) / 60000);
      const s = Math.floor((remaining % 60000) / 1000);
      document.getElementById('miniTimer').textContent =
        String(h).padStart(2, '0') + ':' + String(m).padStart(2, '0') + ':' + String(s).padStart(2, '0');

      if (remaining <= 0) {
        document.getElementById('miniTimer').textContent = 'RAFFLE!';
      }
    }, 1000);

    // Sync with server every 30 seconds
    setInterval(pollGlobalState, 30000);

    // Set initial state immediately
    updateHappiness(0);

    // Initial poll after entering
    document.getElementById('introEnter').addEventListener('click', () => {
      setTimeout(pollGlobalState, 2000);
    });

    // ======================== PIPPIN PROACTIVELY ASKS TASKS ========================
    const sadTaskMessages = [
      { jp: 'ãŠé¡˜ã„â€¦ã‚¿ã‚¹ã‚¯ã‚„ã£ã¦â€¦æ¶ˆãˆã¡ã‚ƒã„ãã†â€¦å³ä¸Šã®ãƒ‘ãƒãƒ«ã‚’è¦‹ã¦â€¦', en: 'onegai... do task... Pippin might disappear desu... check panel top-right ne...' },
      { jp: 'åŠ©ã‘ã¦â€¦å¹¸ã›åº¦ãŒã‚¼ãƒ­â€¦ã‚¿ã‚¹ã‚¯ã‚„ã£ã¦ãã‚ŒãŸã‚‰å…ƒæ°—å‡ºã‚‹ã®ã«â€¦', en: 'tasukete... happiness zero desu... task would make Pippin genki ni naru no ni...' },
      { jp: 'ã•ã¿ã—ã„â€¦èª°ã‹ã‚¿ã‚¹ã‚¯ãƒ‘ãƒãƒ«ã®ãŠä»•äº‹ã‚„ã£ã¦â€¦ãŠé¡˜ã„â€¦', en: 'sabishii... dareka please do task in panel... onegai...' },
      { jp: 'ã“ã®ã¾ã¾ã˜ã‚ƒæ¶ˆãˆã¡ã‚ƒã†â€¦å³ä¸Šã«ã‚¿ã‚¹ã‚¯ã‚ã‚‹ã‹ã‚‰â€¦ãŠé¡˜ã„â€¦', en: 'like this Pippin will vanish desu... tasks are top-right ne... onegai...' },
    ];
    const okTaskMessages = [
      { jp: 'ã­ãˆã­ãˆï¼ãŠä»•äº‹ã‚ã‚‹ã‚“ã ã‘ã©ã€æ‰‹ä¼ã£ã¦ãã‚Œãªã„ï¼Ÿã‚¿ã‚¹ã‚¯ãƒ‘ãƒãƒ«è¦‹ã¦ã¿ã¦ï¼', en: 'nee nee! Pippin have oshigoto for you ne! check task panel desho!' },
      { jp: 'ã¡ã‚‡ã£ã¨ãŠé¡˜ã„ãŒã‚ã‚‹ã®ï¼å³ä¸Šã®ãƒ‘ãƒãƒ«ã«ã‚¿ã‚¹ã‚¯ãŒå‡ºã¦ã‚‹ã‚ˆï¼', en: 'chotto onegai ga aru no! task in panel on right desu yo!' },
      { jp: 'ã‚¿ã‚¹ã‚¯ã‚„ã£ã¦ãã‚ŒãŸã‚‰å¹¸ã›åº¦ãŒä¸ŠãŒã‚‹ã‚ˆï¼ãŠé¡˜ã„ï¼', en: 'if you do task, Pippin happiness go up desu! onegai!' },
      { jp: 'ã²ã¾ãªã‚‰å³ä¸Šã®ã‚¿ã‚¹ã‚¯ã‚„ã£ã¦ã¿ã¦ï¼ãƒ©ãƒƒãƒ•ãƒ«ã«ã‚‚ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã•ã‚Œã‚‹ã‚ˆï¼', en: 'if hima, try tasks top-right ne! you get raffle entry too desu yo!' },
    ];
    const happyTaskMessages = [
      { jp: 'ã‚‚ã£ã¨ã‚¿ã‚¹ã‚¯ã‚„ã£ã¦ãƒ¼ï¼æœ€é«˜ã«æ¥½ã—ã„ã‚ˆï¼', en: 'motto tasks kudasai! saikou ni tanoshii desu yo!' },
      { jp: 'ãªã‚“ã‹æã„ã¦ã»ã—ã„ãªã€œï¼ã‚­ãƒ£ãƒ³ãƒã‚¹é–‹ã‘ã‚‹ã‚ˆï¼', en: 'nanika draw for Pippin ne~! canvas open dekiru yo!' },
      { jp: 'ã¿ã‚“ãªã®ãŠã‹ã’ã§è¶…ãƒãƒƒãƒ”ãƒ¼ï¼ã§ã‚‚ã‚‚ã£ã¨ã‚¿ã‚¹ã‚¯ï¼', en: 'minna no okage de chou happy desu! demo motto tasks ne!' },
    ];

    function getTaskAskMessages() {
      if (currentHappiness >= 60) return happyTaskMessages;
      if (currentHappiness >= 25) return okTaskMessages;
      return sadTaskMessages;
    }

    // After joining, Pippin starts asking for tasks every ~40 seconds
    let taskAskTimer = null;
    function startTaskAsking() {
      if (taskAskTimer) return;
      // First ask after 15 seconds
      setTimeout(() => {
        if (!myWallet) return;
        const msgs = getTaskAskMessages();
        pippinSay(msgs[0].jp, msgs[0].en);
      }, 15000);

      // Then every 45 seconds
      let askIdx = 1;
      taskAskTimer = setInterval(() => {
        if (isSpeaking || !myWallet || !hasEntered) return;
        const msgs = getTaskAskMessages();
        const msg = msgs[askIdx % msgs.length];
        pippinSay(msg.jp, msg.en);
        askIdx++;
      }, 45000);
    }

    // Also re-trigger task asking if wallet was persisted from prior session
    if (myWallet) {
      document.getElementById('taskPanel').classList.add('show');
      loadNewTask();
      startTaskAsking();
    }

    // ======================== SOUND EFFECTS ========================
    const sfxCtx = new (window.AudioContext || window.webkitAudioContext)();
    function playSfx(type) {
      try {
        const osc = sfxCtx.createOscillator();
        const gain = sfxCtx.createGain();
        osc.connect(gain);
        gain.connect(sfxCtx.destination);
        gain.gain.value = 0.12;
        const t = sfxCtx.currentTime;
        if (type === 'complete') {
          // Happy task complete chime
          osc.type = 'sine';
          osc.frequency.setValueAtTime(523, t);
          osc.frequency.setValueAtTime(659, t + 0.1);
          osc.frequency.setValueAtTime(784, t + 0.2);
          gain.gain.setValueAtTime(0.15, t);
          gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
          osc.start(t); osc.stop(t + 0.5);
        } else if (type === 'like') {
          osc.type = 'sine';
          osc.frequency.setValueAtTime(880, t);
          osc.frequency.setValueAtTime(1100, t + 0.08);
          gain.gain.setValueAtTime(0.1, t);
          gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
          osc.start(t); osc.stop(t + 0.2);
        } else if (type === 'sad') {
          osc.type = 'sine';
          osc.frequency.setValueAtTime(330, t);
          osc.frequency.setValueAtTime(262, t + 0.3);
          gain.gain.setValueAtTime(0.08, t);
          gain.gain.exponentialRampToValueAtTime(0.001, t + 0.6);
          osc.start(t); osc.stop(t + 0.6);
        } else if (type === 'join') {
          osc.type = 'triangle';
          osc.frequency.setValueAtTime(440, t);
          osc.frequency.setValueAtTime(554, t + 0.1);
          osc.frequency.setValueAtTime(659, t + 0.2);
          gain.gain.setValueAtTime(0.12, t);
          gain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
          osc.start(t); osc.stop(t + 0.4);
        } else if (type === 'reject') {
          // Rejection buzz
          osc.type = 'square';
          osc.frequency.setValueAtTime(150, t);
          osc.frequency.setValueAtTime(100, t + 0.15);
          gain.gain.setValueAtTime(0.1, t);
          gain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
          osc.start(t); osc.stop(t + 0.4);
        }
      } catch(_) {}
    }

    // Sound effects are now called directly from completeTask (approval/rejection)

    // Activity ticker removed â€” replaced by global chat panel

    // ======================== LIKE DRAWING (GLOBAL FUNCTION) ========================
    window.likeDrawing = async function(btn, drawingId) {
      if (localStorage.getItem('liked_' + drawingId)) return; // already liked
      try {
        const res = await fetch('/api/drawings/' + drawingId + '/like', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: '{}',
        });
        const data = await res.json();
        const countEl = btn.querySelector('.gallery-like-count');
        if (countEl) countEl.textContent = data.likes || 0;
        btn.classList.add('liked');
        localStorage.setItem('liked_' + drawingId, '1');
        playSfx('like');
      } catch(_) {}
    };

    // ======================== PIPPIN PARTICLE EFFECTS (MOOD-BASED) ========================
    let pippinParticles = null;
    let particleGeometry = null;
    let particleMaterial = null;

    function createPippinParticles() {
      if (pippinParticles) { scene.remove(pippinParticles); }
      const count = 60;
      particleGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);
      for (let i = 0; i < count; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 3;
        positions[i * 3 + 1] = Math.random() * 3;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 3;
        colors[i * 3] = 1; colors[i * 3 + 1] = 1; colors[i * 3 + 2] = 1;
      }
      particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      particleMaterial = new THREE.PointsMaterial({
        size: 0.08, vertexColors: true, transparent: true, opacity: 0.7,
        blending: THREE.AdditiveBlending, depthWrite: false,
      });
      pippinParticles = new THREE.Points(particleGeometry, particleMaterial);
      scene.add(pippinParticles);
    }

    function updatePippinParticles(happiness) {
      if (!pippinParticles || !particleGeometry) return;
      const positions = particleGeometry.attributes.position.array;
      const colors = particleGeometry.attributes.color.array;
      const count = positions.length / 3;

      for (let i = 0; i < count; i++) {
        // Move particles upward, reset when too high
        positions[i * 3 + 1] += 0.02 + Math.random() * 0.01;
        if (positions[i * 3 + 1] > 4) {
          positions[i * 3 + 1] = 0;
          positions[i * 3] = (Math.random() - 0.5) * 3;
          positions[i * 3 + 2] = (Math.random() - 0.5) * 3;
        }
        // Horizontal drift
        positions[i * 3] += (Math.random() - 0.5) * 0.02;
        positions[i * 3 + 2] += (Math.random() - 0.5) * 0.02;

        if (happiness < 20) {
          // Sad: grey/blue rain falling DOWN
          positions[i * 3 + 1] -= 0.06; // override upward, move down
          if (positions[i * 3 + 1] < -1) positions[i * 3 + 1] = 4;
          colors[i * 3] = 0.3; colors[i * 3 + 1] = 0.3; colors[i * 3 + 2] = 0.5;
          particleMaterial.size = 0.04;
          particleMaterial.opacity = 0.5;
        } else if (happiness < 50) {
          // Okay: subtle warm sparkles
          colors[i * 3] = 0.9; colors[i * 3 + 1] = 0.8; colors[i * 3 + 2] = 0.5;
          particleMaterial.size = 0.06;
          particleMaterial.opacity = 0.4;
        } else if (happiness < 80) {
          // Happy: pink/gold sparkles
          const t = (i / count);
          colors[i * 3] = 0.9 + t * 0.1; colors[i * 3 + 1] = 0.5 + t * 0.3; colors[i * 3 + 2] = 0.7;
          particleMaterial.size = 0.08;
          particleMaterial.opacity = 0.6;
        } else {
          // Ecstatic: rainbow trail!
          const hue = ((i / count) + Date.now() * 0.0003) % 1;
          const c = new THREE.Color().setHSL(hue, 1, 0.7);
          colors[i * 3] = c.r; colors[i * 3 + 1] = c.g; colors[i * 3 + 2] = c.b;
          particleMaterial.size = 0.1;
          particleMaterial.opacity = 0.8;
        }
      }
      particleGeometry.attributes.position.needsUpdate = true;
      particleGeometry.attributes.color.needsUpdate = true;

      // Follow unicorn
      if (unicornContainer) {
        pippinParticles.position.copy(unicornContainer.position);
        pippinParticles.position.y += 0.5;
      }
    }

    // Create particles after scene loads
    setTimeout(createPippinParticles, 5000);

    // Inject particle update into the render loop â€” find existing animate and patch
    const _origAnimate = animate;
    // We just add a post-render hook via setInterval since animate is requestAnimationFrame
    setInterval(() => { updatePippinParticles(currentHappiness); }, 50);

    // Play sound on task complete (patch the reward display)
    const origTaskReward = taskReward;
    const _origUpdateHappiness = updateHappiness;
    const patchedUpdateHappiness = function(val) {
      _origUpdateHappiness(val);
      if (val <= 15) playSfx('sad');
    };
    // Override updateHappiness
    updateHappiness = patchedUpdateHappiness;

    // SFX and dance now handled directly in completeTask() approval/rejection flow
  </script>
</body>
</html>
